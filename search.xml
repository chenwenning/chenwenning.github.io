<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[GIT项目开发实践]]></title>
    <url>%2F2018%2F06%2F07%2FGIT-Study-Notes%2F</url>
    <content type="text"><![CDATA[一.GIT项目分支开发流程1. 创建d-kaifa分支 git checkout master &amp;&amp; git pull git checkout -b d-kaifa master git reset release **/pom.xml git checkout . git commit -m 创建开发分支并修改内网版本 2. 项目开发并合并到develop分支 git checkout develop &amp;&amp; git pull git merge d-kaifa 3. 项目提测并合并到test分支 git checkout test &amp;&amp; git pull git merge d-kaifa 4. 项目验收并合并到release分支 git checkout release &amp;&amp; git pull git merge d-kaifa 5. 项目上线并合并到master分支 git checkout master &amp;&amp; git pull git merge d-kaifa git commit -m xxx功能 git tag vx.x.x-xxxxxxx git push origin master git push origin vx.x.x-xxxxxxx 代码有问题继续改bug git checkout d-kaifa git merge master 开发。。。 重复上线流程 开发完成 git branch -D d-kaifa ###二.GIT冲突实战 冲突场景： ####1.修改相同的项目A先提交,B再提交，报以下错误： 解决方法： 先 git pull origin hexo 再 git push origin hexo 2.修改相同的文件，不改向同行A先提交，B再提交，报以下错误： 解决方法： 先 git pull origin hexo 再 git push origin hexo ####3.修改相同的文件，改相同行A先提交，B再提交，报以下错误： 解决方法： 先 git pull origin hexo 再手动合并： 手动合并好后： 执行 git add . 执行 git commit -m &quot; 提交hexo&quot; 执行 git push origin hexo 问题解决 ####4.修改相同的文件，改相同行；A:先提交；B:把文件add到暂存区，但不commit; 这时B 进行pull 解决方法： B先执行 git commit -m &quot; 提交hexo&quot; 执行 git pull origin hexo ###三.GIT 文件状态示意图 1.暂存区：执行 git add 文件 后 该文件就到了暂存区 2.修改区：就是之前有这个文件 但是现在修改文件内容 3.未追踪区：就是刚刚添加 还没有执行 git add 操作 ###四.GIT 命令小图]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>GIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后端架构师技术图谱（转载）]]></title>
    <url>%2F2018%2F06%2F07%2F%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%B8%88%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1%2F</url>
    <content type="text"><![CDATA[《后端架构师技术图谱》 更新于20180513 数据结构 队列 集合 链表、数组 字典、关联数组 栈 树 二叉树 完全二叉树 平衡二叉树 二叉查找树（BST） 红黑树 B-，B+，B*树 LSM 树 BitSet 常用算法 排序、查找算法 选择排序 冒泡排序 插入排序 快速排序 归并排序 希尔排序 堆排序 计数排序 桶排序 基数排序 二分查找 Java 中的排序工具 布隆过滤器 字符串比较 KMP 算法 深度优先、广度优先 贪心算法 回溯算法 剪枝算法 动态规划 朴素贝叶斯 推荐算法 最小生成树算法 最短路径算法 并发 多线程 线程安全 一致性、事务 事务 ACID 特性 事务的隔离级别 MVCC 锁 Java中的锁和同步类 公平锁 &amp; 非公平锁 悲观锁 乐观锁 &amp; CAS ABA 问题 CopyOnWrite容器 RingBuffer 可重入锁 &amp; 不可重入锁 互斥锁 &amp; 共享锁 死锁 操作系统 计算机原理 CPU 多级缓存 进程 线程 协程 Linux 设计模式 设计模式的六大原则 23种常见设计模式 应用场景 单例模式 责任链模式 MVC IOC AOP UML 微服务思想 康威定律 运维 &amp; 统计 &amp; 技术支持 常规监控 APM 统计分析 持续集成(CI/CD) Jenkins 环境分离 自动化运维 Ansible puppet chef 测试 TDD 理论 单元测试 压力测试 全链路压测 A/B 、灰度、蓝绿测试 虚拟化 KVM Xen OpenVZ 容器技术 Docker 云技术 OpenStack DevOps 文档管理 中间件 Web Server Nginx OpenResty Apache Httpd Tomcat 架构原理 调优方案 Jetty 缓存 本地缓存 客户端缓存 服务端缓存 Web缓存 Memcached Redis 架构 回收策略 Tair 消息队列 消息总线 消息的顺序 RabbitMQ RocketMQ ActiveMQ Kafka Redis 消息推送 ZeroMQ 定时调度 单机定时调度 分布式定时调度 RPC Dubbo Thrift gRPC 数据库中间件 Sharding Jdbc 日志系统 日志搜集 配置中心 API 网关 网络 协议 OSI 七层协议 TCP/IP HTTP HTTP2.0 HTTPS 网络模型 Epoll Java NIO kqueue 连接和短连接 框架 零拷贝（Zero-copy） 序列化(二进制协议) Hessian Protobuf 数据库 基础理论 数据库设计的三大范式 MySQL 原理 InnoDB 优化 索引 聚集索引, 非聚集索引 复合索引 自适应哈希索引(AHI) explain NoSQL MongoDB Hbase 搜索引擎 搜索引擎原理 Lucene Elasticsearch Solr sphinx 性能 性能优化方法论 容量评估 CDN 网络 连接池 性能调优 大数据 流式计算 Storm Flink Kafka Stream 应用场景 Hadoop HDFS MapReduce Yarn Spark 安全 web 安全 XSS CSRF SQL 注入 Hash Dos 脚本注入 漏洞扫描工具 验证码 DDoS 防范 用户隐私信息保护 序列化漏洞 加密解密 对称加密 哈希算法 非对称加密 服务器安全 数据安全 数据备份 网络隔离 内外网分离 登录跳板机 授权、认证 RBAC OAuth2.0 双因素认证（2FA） 单点登录(SSO) 常用开源框架 开源协议 日志框架 Log4j、Log4j2 Logback ORM 网络框架 Web 框架 Spring 家族 工具框架 分布式设计 扩展性设计 稳定性 &amp; 高可用 硬件负载均衡 软件负载均衡 限流 应用层容灾 跨机房容灾 容灾演练流程 平滑启动 数据库扩展 读写分离模式 分片模式 服务治理 服务注册与发现 服务路由控制 分布式一致 CAP 与 BASE 理论 分布式锁 分布式一致性算法 PAXOS Zab Raft Gossip 两阶段提交、多阶段提交 幂等 分布式一致方案 分布式 Leader 节点选举 TCC(Try/Confirm/Cancel) 柔性事务 分布式文件系统 唯一ID 生成 全局唯一ID 一致性Hash算法 设计思想 &amp; 开发模式 DDD(Domain-driven Design - 领域驱动设计) 命令查询职责分离(CQRS) 贫血，充血模型 Actor 模式 响应式编程 Reactor RxJava Vert.x DODAF2.0 Serverless Service Mesh 项目管理 架构评审 重构 代码规范 代码 Review RUP 看板管理 SCRUM 敏捷开发 极限编程（XP） 结对编程 FMEA管理模式 通用业务术语 技术趋势 政策、法规 法律 严格遵守刑法253法条 架构师素质 团队管理 招聘 资讯 行业资讯 公众号列表 博客 团队博客 个人博客 综合门户、社区 问答、讨论类社区 行业数据分析 专项网站 其他类 推荐参考书 在线电子书 纸质书 开发方面 架构方面 技术管理方面 基础理论 工具方面 大数据方面 技术资源 开源资源 手册、文档、教程 在线课堂 会议、活动 常用APP 找工作 工具 代码托管 文件服务 综合云服务商 VPS （Toc generated by simple-php-github-toc ） 数据结构队列 《java队列——queue详细分析》 非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。 阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。 《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》 集合 《Java Set集合的详解》 链表、数组 《Java集合详解–什么是List》 字典、关联数组 《Java map 详解 - 用法、遍历、排序、常用API等》 栈 《java数据结构与算法之栈（Stack）设计与实现》 《Java Stack 类》 《java stack的详细实现分析》 Stack 是线程安全的。 内部使用数组保存数据，不够时翻倍。 树二叉树每个节点最多有两个叶子节点。 《二叉树》 完全二叉树 《完全二叉树》 叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。 平衡二叉树左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 《浅谈数据结构-平衡二叉树》 《浅谈算法和数据结构: 八 平衡查找树之2-3树》 二叉查找树（BST）二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。 《浅谈算法和数据结构: 七 二叉查找树》 红黑树 《最容易懂得红黑树》 添加阶段后，左旋或者右旋从而再次达到平衡。 《浅谈算法和数据结构: 九 平衡查找树之红黑树》 B-，B+，B*树MySQL是基于B+树聚集索引组织表 《B-树，B+树，B*树详解》 《B-树，B+树与B*树的优缺点比较》 B+ 树的叶子节点链表结构相比于 B- 树便于扫库，和范围检索。LSM 树 LSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的。Hbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。 《LSM树 VS B+树》 B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能。 LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。 《LSM树（Log-Structured Merge Tree）存储引擎》 极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。 优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。 Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。 BitSet经常用于大规模数据的排重检查。 《Java Bitset类》 《Java BitSet（位集）》 常用算法 《常见排序算法及对应的时间复杂度和空间复杂度》 排序、查找算法 《常见排序算法及对应的时间复杂度和空间复杂度》 选择排序 《Java中的经典算法之选择排序（SelectionSort）》 每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。 冒泡排序 《冒泡排序的2种写法》 相邻元素前后交换、把最大的排到最后。 时间复杂度 O(n²) 插入排序 《排序算法总结之插入排序》 快速排序 《坐在马桶上看算法：快速排序》 一侧比另外一次都大或小。 归并排序 《图解排序算法(四)之归并排序》 分而治之，分成小份排序，在合并(重建一个新空间进行复制)。 希尔排序TODO 堆排序 《图解排序算法(三)之堆排序》 排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。 计数排序 《计数排序和桶排序》 和桶排序过程比较像，差别在于桶的数量。 桶排序 《【啊哈！算法】最快最简单的排序——桶排序》 《排序算法（三）：计数排序与桶排序》 桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。 每个桶单独进行排序，然后再遍历每个桶。 基数排序按照个位、十位、百位、…依次来排。 《排序算法系列：基数排序》 《基数排序》 二分查找 《二分查找(java实现)》 要求待查找的序列有序。 时间复杂度 O(logN)。 《java实现二分查找-两种方式》 while + 递归。Java 中的排序工具 《Arrays.sort和Collections.sort实现原理解析》 Collections.sort算法调用的是合并排序。 Arrays.sort() 采用了2种排序算法 – 基本类型数据使用快速排序法，对象数组使用归并排序。 布隆过滤器常用于大数据的排重，比如email，url 等。核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。优点：空间和时间效率都很高。缺点：随着存入的元素数量增加，误算率随之增加。 《布隆过滤器 – 空间效率很高的数据结构》 《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》 《基于Redis的布隆过滤器的实现》 基于 Redis 的 Bitmap 数据结构。 《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》 使用Java中的 BitSet 类 和 加权和hash算法。 字符串比较KMP 算法KMP：Knuth-Morris-Pratt算法（简称KMP）核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。 《字符串匹配的KMP算法》 深度优先、广度优先 《广度优先搜索BFS和深度优先搜索DFS》 贪心算法 《算法：贪婪算法基础》 《常见算法及问题场景——贪心算法》 回溯算法 《 五大常用算法之四：回溯法》 剪枝算法 《α-β剪枝算法》 动态规划 《详解动态规划——邹博讲动态规划》 《动态规划算法的个人理解》 朴素贝叶斯 《带你搞懂朴素贝叶斯分类算法》 P(B|A)=P(A|B)P(B)/P(A) 《贝叶斯推断及其互联网应用1》 《贝叶斯推断及其互联网应用2》 推荐算法 《推荐算法综述》 《TOP 10 开源的推荐系统简介》 最小生成树算法 《算法导论–最小生成树（Kruskal和Prim算法）》 最短路径算法 《Dijkstra算法详解》 并发Java 并发 Java 并发知识合集 JAVA并发知识图谱 多线程 《40个Java多线程问题总结》 线程安全 《Java并发编程——线程安全及解决机制简介》 一致性、事务事务 ACID 特性 《数据库事务ACID特性》 事务的隔离级别 未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。 读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。 可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。 序列化：所有事物串行处理（牺牲了效率） 《理解事务的4种隔离级别》 数据库事务的四大特性及事务隔离级别 《MySQL的InnoDB的幻读问题 》 幻读的例子非常清楚。 通过 SELECT … FOR UPDATE 解决。 《一篇文章带你读懂MySQL和InnoDB》 图解脏读、不可重复读、幻读问题。 MVCC 《【mysql】关于innodb中MVCC的一些理解》 innodb 中 MVCC 用在 Repeatable-Read 隔离级别。 MVCC 会产生幻读问题（更新时异常。） 《轻松理解MYSQL MVCC 实现机制》 通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间 每次只操作比当前版本小（或等于）的 行。 锁Java中的锁和同步类 《Java中的锁分类》 主要包括 synchronized、ReentrantLock、和 ReadWriteLock。 《Java并发之AQS详解》 《Java中信号量 Semaphore》 有数量控制 申请用 acquire，申请不要则阻塞；释放用 release。 《java开发中的Mutex vs Semaphore》 简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。 公平锁 &amp; 非公平锁公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。 《公平锁与非公平锁》 默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。 悲观锁悲观锁如果使用不当（锁的条数过多），会引起服务大面积等待。推荐优先使用乐观锁+重试。 《【MySQL】悲观锁&amp;乐观锁》 乐观锁的方式：版本号+重试方式 悲观锁：通过 select … for update 进行行锁(不可读、不可写，share 锁可读不可写)。 《Mysql查询语句使用select.. for update导致的数据库死锁分析》 mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。 锁相同数据的不同索引条件可能会引起死锁。 《Mysql并发时经典常见的死锁原因及解决方法》 乐观锁 &amp; CAS 《乐观锁的一种实现方式——CAS》 和MySQL乐观锁方式相似，只不过是通过和原值进行比较。 ABA 问题由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。 《Java CAS 和ABA问题》 《Java 中 ABA问题及避免》 AtomicStampedReference 和 AtomicStampedReference。 CopyOnWrite容器可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。 《JAVA中写时复制(Copy-On-Write)Map实现》 实现读写分离，读取发生在原始数据上，写入发生在副本上。 不用加锁，通过最终一致实现一致性。 《聊聊并发-Java中的Copy-On-Write容器》 RingBuffer 《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》 可重入锁 &amp; 不可重入锁 《可重入锁和不可重入锁》 通过简单代码举例说明可重入锁和不可重入锁。 可重入锁指同一个线程可以再次获得之前已经获得的锁。 可重入锁可以用户避免死锁。 Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock 《ReenTrantLock可重入锁（和synchronized的区别）总结》 synchronized 使用方便，编译器来加锁，是非公平锁。 ReenTrantLock 使用灵活，锁的公平性可以定制。 相同加锁场景下，推荐使用 synchronized。 互斥锁 &amp; 共享锁互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。 《ReadWriteLock场景应用》 死锁 《“死锁”四个必要条件的合理解释》 互斥、持有、不可剥夺、环形等待。 Java如何查看死锁？ JConsole 可以识别死锁。 java多线程系列：死锁及检测 jstack 可以显示死锁。 操作系统计算机原理 《操作系统基础知识——操作系统的原理，类型和结构》 CPU多级缓存典型的 CPU 有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。 《从Java视角理解CPU缓存和伪共享》 进程TODO 线程 《线程的生命周期及状态转换详解》 协程 《终结python协程—-从yield到actor模型的实现》 线程的调度是由操作系统负责，协程调度是程序自行负责 与线程相比，协程减少了无谓的操作系统切换. 实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换. Linux 《Linux 命令大全》 设计模式设计模式的六大原则 《设计模式的六大原则》 开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。 里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。 依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。 接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。 迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。 合成复用原则：尽量使用合成/聚合,而不是使用继承。 23种常见设计模式 《设计模式》 《23种设计模式全解析》 应用场景 《细数JDK里的设计模式》 结构型模式： 适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。 桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC； 组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。 装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。 享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。 代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy 创建模式: 抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。 建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。 工厂方法：就是 一个返* 回具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。 原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。 单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。 行为模式： 责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。 命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。 解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。 迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。 中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。 空对象模式：如 java.util.Collections#emptyList()。 观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。 模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。 《Spring-涉及到的设计模式汇总》 《Mybatis使用的设计模式》 单例模式 《单例模式的三种实现 以及各自的优缺点》 《单例模式－－反射－－防止序列化破坏单例模式》 使用枚举类型。 责任链模式TODO MVC 《MVC 模式》 模型(model)－视图(view)－控制器(controller) IOC 《理解 IOC》 《IOC 的理解与解释》 正向控制：传统通过new的方式。反向控制，通过容器注入对象。 作用：用于模块解耦。 DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。 AOP 《轻松理解AOP(面向切面编程)》 《Spring AOP详解》 《Spring AOP的实现原理》 Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。 《Spring AOP 实现原理与 CGLIB 应用》 Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类 UML 《UML教程》 微服务思想 《微服务架构设计》 《微服务架构技术栈选型手册》 康威定律 《微服务架构的理论基础 - 康威定律》 定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。 定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。 定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。 定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。 《微服务架构核⼼20讲》 运维 &amp; 统计 &amp; 技术支持常规监控 《腾讯业务系统监控的修炼之路》 监控的方式：主动、被动、旁路(比如舆情监控) 监控类型： 基础监控、服务端监控、客户端监控、监控、用户端监控 监控的目标：全、块、准 核心指标：请求量、成功率、耗时 《开源还是商用？十大云运维监控工具横评》 Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。 《监控报警系统搭建及二次开发经验》 命令行监控工具 《常用命令行监控工具》 top、sar、tsar、nload 《20个命令行工具监控 Linux 系统性能》 《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》 APMAPM — Application Performance Management 《Dapper，大规模分布式系统的跟踪系统》 CNCF OpenTracing，中文版 主要开源软件，按字母排序 Apache SkyWalking CAT CNCF jaeger Pinpoint Zipkin 《开源APM技术选型与实战》 主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。 统计分析 《流量统计的基础：埋点》 常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度 《APP埋点常用的统计工具、埋点目标和埋点内容》 第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。 《美团点评前端无痕埋点实践》 所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。 持续集成(CI/CD) 《持续集成是什么？》 《8个流行的持续集成工具》 Jenkins 《使用Jenkins进行持续集成》 环境分离开发、测试、生成环境分离。 《开发环境、生产环境、测试环境的基本理解和区》 自动化运维Ansible 《Ansible中文权威指南》 《Ansible基础配置和企业级项目实用案例》 puppet 《自动化运维工具——puppet详解》 chef 《Chef 的安装与使用》 测试TDD 理论 《深度解读 - TDD（测试驱动开发）》 基于测试用例编码功能代码，XP（Extreme Programming）的核心实践. 好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈； 单元测试 《Java单元测试之JUnit篇》 《JUnit 4 与 TestNG 对比》 TestNG 覆盖 JUnit 功能，适用于更复杂的场景。 《单元测试主要的测试功能点》 模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。 压力测试 《Apache ab 测试使用指南》 《大型网站压力测试及优化方案》 《10大主流压力/负载/性能测试工具推荐》 《真实流量压测工具 tcpcopy应用浅析》 《nGrinder 简易使用教程》 全链路压测 《京东618：升级全链路压测方案，打造军演机器人ForceBot》 《饿了么全链路压测的探索与实践》 《四大语言，八大框架｜滴滴全链路压测解决之道》 《全链路压测经验》 A/B 、灰度、蓝绿测试 《技术干货 | AB 测试和灰度发布探索及实践》 《nginx 根据IP 进行灰度发布》 《蓝绿部署、A/B 测试以及灰度发布》 虚拟化 《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》 KVM 《KVM详解，太详细太深入了，经典》 《【图文】KVM 虚拟机安装详解》 Xen 《Xen虚拟化基本原理详解》 OpenVZ 《开源Linux容器 OpenVZ 快速上手指南》 容器技术Docker 《几张图帮你理解 docker 基本原理及快速入门》 《Docker 核心技术与实现原理》 《Docker 教程》 云技术OpenStack 《OpenStack构架知识梳理》 DevOps 《一分钟告诉你究竟DevOps是什么鬼？》 《DevOps详解》 文档管理 Confluence-收费文档管理系统 GitLab? Wiki 中间件Web ServerNginx 《Ngnix的基本学习-多进程和Apache的比较》 Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。 事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。 《nginx与Apache的对比以及优缺点》 nginx只适合静态和反向代理，不适合处理动态请求。 OpenResty 官方网站 《浅谈 OpenResty》 通过 Lua 模块可以在Nginx上进行开发。 Apache Httpd 官方网站 Tomcat架构原理 《TOMCAT原理详解及请求过程》 《Tomcat服务器原理详解》 《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》 《四张图带你了解Tomcat系统架构》 《JBoss vs. Tomcat: Choosing A Java Application Server》 Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Srping。 Jboss 实现全部了JEE特性，软件开源免费、文档收费。 调优方案 《Tomcat 调优方案》 启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）； 《tomcat http协议与ajp协议》 《AJP与HTTP比较和分析》 AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。 并发高时，AJP协议优于HTTP协议。 Jetty 《Jetty 的工作原理以及与 Tomcat 的比较》 《jetty和tomcat优势比较》 架构比较:Jetty的架构比Tomcat的更为简单。 性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I/O请求上更占优势，Tomcat默认采用BIO处理I/O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。 其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。 缓存 《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》 本地缓存 《HashMap本地缓存》 《EhCache本地缓存》 堆内、堆外、磁盘三级缓存。 可按照缓存空间容量进行设置。 按照时间、次数等过期策略。 《Guava Cache》 简单轻量、无堆外、磁盘缓存。 《Nginx本地缓存》 《Pagespeed—懒人工具，服务器端加速》 客户端缓存 《浏览器端缓存》 主要是利用 Cache-Control 参数。 《H5 和移动端 WebView 缓存机制解析与实战》 服务端缓存Web缓存 nuster - nuster cache varnish - varnish cache squid - squid cache Memcached 《Memcached 教程》 《深入理解Memcached原理》 采用多路复用技术提高并发性。 slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。 《Memcached软件工作原理》 《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》 《memcache 中 add 、 set 、replace 的区别》 区别在于当key存在还是不存在时，返回值是true和false的。 《memcached全面剖析》 Redis 《Redis 教程》 《redis底层原理》 使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。 使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。 《Redis持久化方式》 RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。 AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。 也可以两者结合使用。 《分布式缓存–序列3–原子操作与CAS乐观锁》 架构 《Redis单线程架构》 回收策略 《redis的回收策略》 Tair 官方网站 《Tair和Redis的对比》 特点：可以配置备份节点数目，通过异步同步到备份节点 一致性Hash算法。 架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。 几种存储引擎: MDB，完全内存性，可以用来存储Session等数据。 Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作 LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。 Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。 消息队列 《消息队列-推/拉模式学习 &amp; ActiveMQ及JMS学习》 RabbitMQ 消费者默认是推模式（也支持拉模式）。 Kafka 默认是拉模式。 Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。 Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。 《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》 消息总线消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。 《消息总线VS消息队列》 消息的顺序 《如何保证消费者接收消息的顺序》 RabbitMQ支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景。 《RabbitMQ的应用场景以及基本原理介绍》 《消息队列之 RabbitMQ》 《RabbitMQ之消息确认机制（事务+Confirm）》 RocketMQJava实现，推拉模式都是支持，吞吐量逊于Kafka。可以保证消息顺序。 《RocketMQ 实战之快速入门》 《RocketMQ 源码解析》 ActiveMQ纯Java实现，兼容JMS，可以内嵌于Java应用中。 《ActiveMQ消息队列介绍》 Kafka高吞吐量、采用拉模式。适合高IO场景，比如日志同步。 官方网站 《各消息队列对比，Kafka深度解析，众人推荐，精彩好文！》 《Kafka分区机制介绍与示例》 Redis 消息推送生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。 《Redis学习笔记之十：Redis用作消息队列》 ZeroMQ TODO 定时调度单机定时调度 《linux定时任务cron配置》 《Linux cron运行原理》 fork 进程 + sleep 轮询 《Quartz使用总结》 《Quartz源码解析 —- 触发器按时启动原理》 《quartz原理揭秘和源码解读》 定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。 分布式定时调度 《这些优秀的国产分布式任务调度系统，你用过几个？》 opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares 《Quartz任务调度的基本实现原理》 Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的 《Elastic-Job-Lite 源码解析》 《Elastic-Job-Cloud 源码解析》 RPC 《从零开始实现RPC框架 - RPC原理及实现》 核心角色：Server: 暴露服务的服务提供方、Client: 调用远程服务的服务消费方、Registry: 服务注册与发现的注册中心。 《分布式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比较》 Dubbo 官方网站 dubbo实现原理简单介绍 SPI TODO Thrift 官方网站 《Thrift RPC详解》 支持多语言，通过中间语言定义接口。 gRPC服务端可以认证加密，在外网环境下，可以保证数据安全。 官方网站 《你应该知道的RPC原理》 数据库中间件Sharding Jdbc 官网 日志系统日志搜集 《从零开始搭建一个ELKB日志收集系统》 《用ELK搭建简单的日志收集分析系统》 《日志收集系统-探究》 配置中心 Apollo - 携程开源的配置中心应用 Spring Boot 和 Spring Cloud 支持推、拉模式更新配置 支持多种语言 《基于zookeeper实现统一配置管理》 《 Spring Cloud Config 分布式配置中心使用教程》 servlet 3.0 异步特性可用于配置中心的客户端 《servlet3.0 新特性——异步处理》 API 网关主要职责：请求转发、安全认证、协议转换、容灾。 《API网关那些儿》 《谈API网关的背景、架构以及落地方案》 《使用Zuul构建API Gateway》 《Spring Cloud Gateway 源码解析》 《HTTP API网关选择之一Kong介绍》 网络协议OSI 七层协议 《OSI七层协议模型、TCP/IP四层模型学习笔记》 TCP/IP 《深入浅出 TCP/IP 协议》 《TCP协议中的三次握手和四次挥手》 HTTP 《http协议详解(超详细)》 HTTP2.0 《HTTP 2.0 原理详细分析》 《HTTP2.0的基本单位为二进制帧》 利用二进制帧负责传输。 多路复用。 HTTPS 《https原理通俗了解》 使用非对称加密协商加密算法 使用对称加密方式传输数据 使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。 《八大免费SSL证书-给你的网站免费添加Https安全加密》 网络模型 《web优化必须了解的原理之I/o的五种模型和web的三种工作模式》 五种I/O模型：阻塞I/O，非阻塞I/O，I/O复用、事件(信号)驱动I/O、异步I/O，前四种I/O属于同步操作，I/O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。 三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。 《select、poll、epoll之间的区别总结》 select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。 select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。 select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。 poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。 《select，poll，epoll比较 》 在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。 《深入理解Java NIO》 NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务 《BIO与NIO、AIO的区别》 《两种高效的服务器设计模型：Reactor和Proactor模型》 Epoll 《epoll使用详解（精髓）》 Java NIO 《深入理解Java NIO》 《Java NIO编写Socket服务器的一个例子》 kqueue 《kqueue用法简介》 连接和短连接 《TCP/IP系列——长连接与短连接的区别》 框架 《Netty原理剖析》 Reactor 模式介绍。 Netty 是 Reactor 模式的一种实现。 零拷贝（Zero-copy） 《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》 多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。 序列化(二进制协议)Hessian 《Hessian原理分析》Binary-RPC;不仅仅是序列化 Protobuf 《Protobuf协议的Java应用例子》Goolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写 .proto 文件。 《Protocol Buffers序列化协议及应用》 * 关于协议的解释；缺点：可读性差; 《简单的使用 protobuf 和 protostuff》 protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。 数据库基础理论数据库设计的三大范式 《数据库的三大范式以及五大约束》 第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性； 第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情； 第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）； MySQL原理 《MySQL的InnoDB索引原理详解》 《MySQL存储引擎－－MyISAM与InnoDB区别》 两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁 《myisam和innodb索引实现的不同》 InnoDB 《一篇文章带你读懂Mysql和InnoDB》 优化 《MySQL36条军规》 《MYSQL性能优化的最佳20+条经验》 《SQL优化之道》 《mysql数据库死锁的产生原因及解决办法》 《导致索引失效的可能情况》 《 MYSQL分页limit速度太慢优化方法》 原则上就是缩小扫描范围。 索引聚集索引, 非聚集索引 《MySQL 聚集索引/非聚集索引简述》 《MyISAM和InnoDB的索引实现》 MyISAM 是非聚集，InnoDB 是聚集 复合索引 《复合索引的优点和注意事项》 自适应哈希索引(AHI) 《InnoDB存储引擎——自适应哈希索引》 explain 《MySQL 性能优化神器 Explain 使用分析》 NoSQLMongoDB MongoDB 教程 《Mongodb相对于关系型数据库的优缺点》 优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越； 缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方； Hbase 《简明 HBase 入门教程（开篇）》 《深入学习HBase架构原理》 《传统的行存储和（HBase）列存储的区别》 《Hbase与传统数据库的区别》 空数据不存储，节省空间，且适用于并发。 《HBase Rowkey设计》 rowkey 按照字典顺序排列，便于批量扫描。 通过散列可以避免热点。 搜索引擎搜索引擎原理 《倒排索引–搜索引擎入门》 Lucene 《Lucene入门简介》 Elasticsearch 《Elasticsearch学习，请先看这一篇！》 《Elasticsearch索引原理》 Solr 《 Apache Solr入门教程》 《elasticsearch与solr比较》 sphinx 《Sphinx 的介绍和原理探索》 性能性能优化方法论 《15天的性能优化工作，5方面的调优经验》 代码层面、业务层面、数据库层面、服务器层面、前端优化。 《系统性能优化的几个方面》 容量评估 《联网性能与容量评估的方法论和典型案例》 《互联网架构，如何进行容量设计？》 评估总访问量、评估平均访问量QPS、评估高峰QPS、评估系统、单机极限QPS CDN 网络 《CDN加速原理》 《国内有哪些比较好的 CDN？》 连接池 《主流Java数据库连接池比较与开发配置实战》 性能调优 《九大Java性能调试工具，必备至少一款》 大数据流式计算Storm 官方网站 《最详细的Storm入门教程》 Flink 《Flink之一 Flink基本原理介绍》 Kafka Stream 《Kafka Stream调研：一种轻量级流计算模式》 应用场景例如： 广告相关实时统计； 推荐系统用户画像标签实时更新； 线上服务健康状况实时监测； 实时榜单； 实时数据统计。 Hadoop 《用通俗易懂的话说下hadoop是什么,能做什么》 《史上最详细的Hadoop环境搭建》 HDFS 《【Hadoop学习】HDFS基本原理》 MapReduce 《用通俗易懂的大白话讲解Map/Reduce原理》 《 简单的map-reduce的java例子》 Yarn 《初步掌握Yarn的架构及原理》 Spark 《Spark(一): 基本架构及原理》 安全web 安全XSS 《xss攻击原理与解决方法》CSRF 《CSRF原理及防范》 SQL 注入 《SQL注入》 Hash Dos 《邪恶的JAVA HASH DOS攻击》 利用JsonObjet 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。 《一种高级的DoS攻击-Hash碰撞攻击》 《关于Hash Collision DoS漏洞：解析与解决方案》 脚本注入 《上传文件漏洞原理及防范》 漏洞扫描工具 《DVWA》 W3af OpenVAS详解 验证码 《验证码原理分析及实现》 《详解滑动验证码的实现原理》 滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。 《淘宝滑动验证码研究》 DDoS 防范 《学习手册：DDoS的攻击方式及防御手段》 《免费DDoS攻击测试工具大合集》 用户隐私信息保护 用户密码非明文保存，加动态salt。 身份证号，手机号如果要显示，用 “*” 替代部分字符。 联系方式在的显示与否由用户自己控制。 TODO 《个人隐私包括哪些》 《在互联网上，隐私的范围包括哪些？》 《用户密码保存》 序列化漏洞 《Lib之过？Java反序列化漏洞通用利用分析》 加密解密对称加密 《常见对称加密算法》 DES、3DES、Blowfish、AES DES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。 DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。 哈希算法 《常用的哈希算法》 MD5 和 SHA-1 已经不再安全，已被弃用。 目前 SHA-256 是比较安全的。 《基于Hash摘要签名的公网URL签名验证设计方案》 非对称加密 《常见非对称加密算法》 RSA、DSA、ECDSA(螺旋曲线加密算法) 和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。 256位的ECC秘钥的安全性等同于3072位的RSA秘钥。 《区块链的加密技术》 服务器安全 《Linux强化论：15步打造一个安全的Linux服务器》 数据安全数据备份TODO 网络隔离内外网分离TODO 登录跳板机在内外环境中通过跳板机登录到线上主机。 《搭建简易堡垒机》 授权、认证RBAC 《基于组织角色的权限设计》 《权限系统与RBAC模型概述》 《Spring整合Shiro做权限控制模块详细案例分析》 OAuth2.0 《理解OAuth 2.0》 《一张图搞定OAuth2.0》 双因素认证（2FA）2FA - Two-factor authentication，用于加强登录验证 常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key） 【《双因素认证（2FA）教程》】(http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html) 单点登录(SSO) 《单点登录原理与简单实现》 CAS单点登录框架 常用开源框架开源协议 《开源协议的选择》 如何选择一个开源软件协议 日志框架Log4j、Log4j2 《log4j 详细讲解》 《log4j2 实际使用详解》 《Log4j1,Logback以及Log4j2性能测试对比》 Log4J 异步日志性能优异。 Logback 《最全LogBack 详解、含java案例和配置说明》 ORM 《ORM框架使用优缺点》 主要目的是为了提高开发效率。 MyBatis： 《mybatis缓存机制详解》 一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效 二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。 《MyBatis学习之代码生成器Generator》 网络框架TODO Web 框架Spring 家族Spring Spring 简明教程 Spring Boot 官方网站 《Spring Boot基础教程》 Spring Cloud Spring Boot 中文索引站 Spring Cloud 中文文档 《Spring Cloud基础教程》 工具框架 《Apache Commons 工具类介绍及简单使用》 《Google guava 中文教程》 分布式设计扩展性设计 《架构师不可不知的十大可扩展架构》 总结下来，通用的套路就是分布、缓存及异步处理。 《可扩展性设计之数据切分》 水平切分+垂直切分 利用中间件进行分片如，MySQL Proxy。 利用分片策略进行切分，如按照ID取模。 《说说如何实现可扩展性的大型网站架构》 分布式服务+消息队列。 《大型网站技术架构（七）–网站的可扩展性架构》 稳定性 &amp; 高可用 《系统设计：关于高可用系统的一些技术方案》 可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。 隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。 解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。 限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。 降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。 熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。 自动化测试：通过完善的测试，减少发布引起的故障。 灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。 《关于高可用的系统》 设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。 硬件负载均衡 《转！！负载均衡器技术Nginx和F5的优缺点对比》 主要是和F5对比。 《软/硬件负载均衡产品 你知多少？》 软件负载均衡 《几种负载均衡算法》 轮寻、权重、负载、最少连接、QoS 《DNS负载均衡》 配置简单，更新速度慢。 《Nginx负载均衡》 简单轻量、学习成本低；主要适用于web应用。 《借助LVS+Keepalived实现负载均衡 》 配置比较负载、只支持到4层，性能较高。 《HAProxy用法详解 全网最详细中文文档》 支持到七层（比如HTTP）、功能比较全面，性能也不错。 《Haproxy+Keepalived+MySQL实现读均衡负载》 主要是用户读请求的负载均衡。 《rabbitmq+haproxy+keepalived实现高可用集群搭建》 限流 《谈谈高并发系统的限流》 计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。 漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。 令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。 Nginx 限流：通过 limit_req 等模块限制并发连接数。 应用层容灾 《防雪崩利器：熔断器 Hystrix 的原理与使用》 雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。 雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。 Hystrix设计原则： 资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。 熔断开关：服务的健康状况 = 请求失败数 / 请求总数，通过阈值设定和滑动窗口控制开关。 命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。 《缓存穿透，缓存击穿，缓存雪崩解决方案分析》 《缓存击穿、失效以及热点key问题》 主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期； 热点数据：热点数据单独存储；使用本地缓存；分成多个子key； 跨机房容灾 《“异地多活”多机房部署经验谈》 通过自研中间件进行数据同步。 《异地多活（异地双活）实践经验》 注意延迟问题，多次跨机房调用会将延时放大数倍。 建房间专线很大概率会出现问题，做好运维和程序层面的容错。 不能依赖于程序端数据双写，要有自动同步方案。 数据永不在高延迟和较差网络质量下，考虑同步质量问题。 核心业务和次要业务分而治之，甚至只考虑核心业务。 异地多活监控部署、测试也要跟上。 业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。 控制跨机房消息体大小，越小越好。 考虑使用docker容器虚拟化技术，提高动态调度能力。 容灾技术及建设经验介绍 容灾演练流程 《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》 常见故障画像 案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。 平滑启动 平滑重启应用思路1.端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用 《JVM安全退出（如何优雅的关闭java服务）》推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。 《常见Java应用如何优雅关闭》Java、Srping、Dubbo 优雅关闭方式。 数据库扩展读写分离模式 《Mysql主从方案的实现》 《搭建MySQL主从复制经典架构》 《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》 《DRBD+Heartbeat+Mysql高可用读写分离架构》 DRDB 进行磁盘复制，避免单点问题。 《MySQL Cluster 方式》 分片模式 《分库分表需要考虑的问题及方案》 中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。 问题：事务、Join、迁移、扩容、ID、分页等。 事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。 分库策略：数值范围；取模；日期等。 分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。 《MySql分表和表分区详解》 分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。 分表：物理上创建不同的表、客户端需要管理分表路由。 服务治理服务注册与发现 《永不失联！如何实现微服务架构中的服务发现？》 客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。 服务器端服务发现模式：客户端通过负载均衡查询服务实例。 《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》 CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap） 作者认为目前 Consul 对 Spring cloud 的支持比较好。 《基于Zookeeper的服务注册与发现》 优点：API简单、Pinterest，Airbnb 在用、多语言、通过watcher机制来实现配置PUSH，能快速响应配置变化。 服务路由控制 《分布式服务框架学习笔记4 服务路由》 原则：透明化路由 负载均衡策略：随机、轮询、服务调用延迟、一致性哈希、粘滞连接 本地路由有限策略：injvm(优先调用jvm内部的服务)，innative(优先使用相同物理机的服务),原则上找距离最近的服务。 配置方式：统一注册表；本地配置；动态下发。 分布式一致CAP 与 BASE 理论 《从分布式一致性谈到CAP理论、BASE理论》 一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致) CAP：一致性、可用性、分区容错性(网络故障引起) BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性） BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。 分布式锁 《分布式锁的几种实现方式》 基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入； 基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。 Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。 《基于Zookeeper的分布式锁》 清楚的原理描述 + Java 代码示例。 《jedisLock—redis分布式锁实现》 基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。 《Memcached 和 Redis 分布式锁方案》 利用 memcached 的 add（有别于set）操作，当key存在时，返回false。 分布式一致性算法PAXOS 《分布式系列文章——Paxos算法原理与推导》 《Paxos–&gt;Fast Paxos–&gt;Zookeeper分析》 《【分布式】Zookeeper与Paxos》 Zab 《Zab：Zookeeper 中的分布式一致性协议介绍》 Raft 《Raft 为什么是更易理解的分布式一致性算法》 三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人） 通过随机等待的方式发出投票，得票多的获胜。 Gossip 《Gossip算法》 两阶段提交、多阶段提交 《关于分布式事务、两阶段提交协议、三阶提交协议》 幂等 《分布式系统—幂等性设计》 幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。 常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。 分布式一致方案 《分布式系统事务一致性解决方案》 《保证分布式系统数据一致性的6种方案》 分布式 Leader 节点选举 《利用zookeeper实现分布式leader节点选举》 TCC(Try/Confirm/Cancel) 柔性事务 《传统事务与柔性事务》 基于BASE理论：基本可用、柔性状态、最终一致。 解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。 分布式文件系统 说说分布式文件存储系统-基本架构 ？ 《各种分布式文件系统的比较》 ？ HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。 FastDFS：轻量级、适合小文件。 唯一ID 生成全局唯一ID 《高并发分布式系统中生成全局唯一Id汇总》 Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器) Flicker 方案：MySQL自增ID + “REPLACE INTO XXX:SELECT LAST_INSERT_ID();” UUID：缺点，无序，字符串过长，占用空间，影响检索性能。 MongoDB 方案：利用 ObjectId。缺点：不能自增。 《TDDL 在分布式下的SEQUENCE原理》 在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。 每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。 客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。 一致性Hash算法 《一致性哈希算法》 设计思想 &amp; 开发模式DDD(Domain-driven Design - 领域驱动设计) 《浅谈我对DDD领域驱动设计的理解》 概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）。 过程：理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度。 设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。 《领域驱动设计的基础知识总结》 领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。 界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。 领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字； 领域通用语言：领域专家、开发设计人员都能立即的语言或工具。 经典分层架构：用户界面/展示层、应用层、领域层、基础设施层，是四层架构模式。 使用的模式： 关联尽量少，尽量单项，尽量降低整体复杂度。 实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。 值对象（Value Object）：没有唯一标识，且属性值不可变，小二简单的对象，比如Date。 领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。 聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互； 工厂（Factory）：类似于设计模式中的工厂模式。 仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。 《领域驱动设计(DDD)实现之路》 聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。 《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》 命令查询职责分离(CQRS)CQRS — Command Query Responsibility Seperation 《领域驱动设计系列 (六)：CQRS》 核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。 《DDD CQRS架构和传统架构的优缺点比较》 最终一致的设计理念；依赖于高可用消息中间件。 《CQRS架构简介》 一个实现 CQRS 的抽象案例。 《深度长文：我对CQRS/EventSourcing架构的思考》 CQRS 模式分析 + 12306 抢票案例 贫血，充血模型 《贫血，充血模型的解释以及一些经验》 失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。 贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重； 充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。 肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。 作者主张使用贫血模式。 Actor 模式TODO 响应式编程ReactorTODO RxJavaTODO Vert.xTODO DODAF2.0 《DODAF2.0方法论》 《DODAF2.0之能力视角如何落地》 Serverless无需过多关系服务器的服务架构理念。 《什么是Serverless无服务器架构？》 Serverless 不代表出去服务器，而是去除对服务器运行状态的关心。 Serverless 代表一思维方式的转变，从“构建一套服务在一台服务器上，对对个事件进行响应转变为构建一个为服务器，来响应一个事件”。 Serverless 不代表某个具体的框架。 《如何理解Serverless？》 依赖于 Baas （(Mobile) Backend as a Service） 和 Faas （Functions as a service） Service Mesh 《什么是Service Mesh？》 《初识 Service Mesh》 《什么是Service Mesh？》 项目管理架构评审 《架构设计之如何评审架构设计说明书》 《人人都是架构师：非功能性需求》 重构 《架构之重构的12条军规》 代码规范 《阿里巴巴Java开发手册》 代码 Review制度还是制度!另外，每个公司需要根据自己的需求和目标制定自己的 check list 《为什么你做不好 Code Review？》 代码 review 做的好，在于制度建设。 《从零开始Code Review》 《Code Review Checklist》 《Java Code Review Checklist》 《如何用 gitlab 做 code review》 RUP 《运用RUP 4+1视图方法进行软件架构设计》 看板管理 《说说看板在项目中的应用》 SCRUMSCRUM - 争球 3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。 3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图； 五个价值观：专注、勇气、公开、承诺、尊重。 《敏捷项目管理流程-Scrum框架最全总结！》 《敏捷其实很简单3—敏捷方法之scrum》 敏捷开发TODO 极限编程（XP）XP - eXtreme Programming 《主流敏捷开发方法：极限编程XP》 是一种指导开发人员的方法论。 4大价值： 沟通：鼓励口头沟通，提高效率。 简单：够用就好。 反馈：及时反馈、通知相关人。 勇气：提倡拥抱变化，敢于重构。 5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。 5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。 结对编程边写码，边review。能够增强代码质量、减少bug。 《结对编程》 PDCA 循环质量管理P——PLAN 策划，D——DO 实施，C——CHECK 检查，A——ACT 改进 《PDCA》 FMEA管理模式TODO 通用业务术语TODO 技术趋势TODO 政策、法规TODO 法律严格遵守刑法253法条我国刑法第253条之一规定： 国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。 窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。 单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。 最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪” 《非法获取公民个人信息罪》 架构师素质 《架构师画像》 业务理解和抽象能力 NB的代码能力 全面：1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面； 全局：是否考虑到了对上下游的系统的影响。 权衡：权衡投入产出比；优先级和节奏控制； 《关于架构优化和设计，架构师必须知道的事情》 要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依赖、注意服务之间依赖所有造成的链式失败及影响等。 基础设施、配置、测试、开发、运维综合考虑。 考虑人、团队、和组织的影响。 《如何才能真正的提高自己，成为一名出色的架构师？》 《架构师的必备素质和成长途径》 素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。 成长路径：2年积累知识、4年积累技能和组内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。 《架构设计师—你在哪层楼？》 第一层的架构师看到的只是产品本身 第二层的架构师不仅看到自己的产品，还看到了整体的方案 第三层的架构师看到的是商业价值 团队管理TODO 招聘资讯行业资讯 36kr Techweb 公众号列表TODO 博客团队博客 阿里中间件博客 美团点评技术团队博客 个人博客 阮一峰的网络日志 酷壳 - COOLSHELL-陈皓 hellojava-阿里毕玄 Cm’s Blog 程序猿DD-翟永超-《Spring Cloud微服务实战》作者 综合门户、社区国内： CSDN 老牌技术社区、不必解释。 51cto.com ITeye 偏 Java 方向 博客园 ChinaUnix 偏 Linux 方向 开源中国社区 深度开源 伯乐在线 涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。 ITPUB 腾讯云— 云+社区 阿里云— 云栖社区 IBM DeveloperWorks 开发者头条 LinkedKeeper 国外： DZone Reddit 问答、讨论类社区 segmentfault 问答+专栏 知乎 stackoverflow 行业数据分析 艾瑞网 QUEST MOBILE 国家数据 TalkingData 专项网站 测试: 领测国际 测试窝 TesterHome 运维: * [运维派](http://www.yunweipai.com/) * [Abcdocker](https://www.abcdocker.com/) Java: ImportNew 专注于 Java 技术分享 HowToDoInJava 英文博客 安全 红黑联盟 FreeBuf 大数据 中国大数据 其他专题网站： DockerInfo 专注于 Docker 应用及咨询、教程的网站。 Linux公社 Linux 主题社区 其他类 程序员技能图谱 推荐参考书在线电子书 《深入理解Spring Cloud与微服务构建》 《阿里技术参考图册-研发篇》 《阿里技术参考图册-算法篇》 《2018美团点评技术年货（合辑）》70M InfoQ《架构师》月刊 《架构师之路》 纸质书开发方面 《阿里巴巴Java开发手册》京东 淘宝 架构方面 《软件架构师的12项修炼：技术技能篇》京东 淘宝 《架构之美》京东 淘宝 《分布式服务架构》京东 淘宝 《聊聊架构》 京东 淘宝 《云原生应用架构实践》京东 淘宝 《亿级流量网站架构核心技术》京东 淘宝 《淘宝技术这十年》京东 淘宝 《企业IT架构转型之道-中台战略思想与架构实战》 京东 淘宝 《高可用架构（第1卷）》京东 淘宝 技术管理方面 《CTO说》京东 淘宝 《技术管理之巅》京东 淘宝 《网易一千零一夜：互联网产品项目管理实战》京东 淘宝 基础理论 《数学之美》京东 淘宝 《编程珠玑》京东 淘宝 工具方面TODO 大数据方面技术资源开源资源 github Apache 软件基金会 手册、文档、教程国内： W3Cschool Runoob.com HTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。 Love2.io 很多很多中文在线电子书，是一个全新的开源技术文档分享平台。 gitbook.cn 付费电子书。 ApacheCN AI、大数据方面系列中文文档。 国外： Quick Code 免费在线技术教程。 gitbook.com 有部分中文电子书。 Cheatography Cheat Sheets 大全，单页文档网站。 Tutorialspoint 知名教程网站，提供Java、Python、JS、SQL、大数据等高质量入门教程。 在线课堂 学徒无忧 极客时间 segmentfault 斯达克学院 牛客网 极客学院 51CTO学院 会议、活动 QCon ArchSummit GITC全球互联网技术大会 活动发布平台: 活动行 常用APP 极客时间 得到 找工作 Boss直聘 拉勾网 猎聘 100Offer 工具 极客搜索 技术文章搜索引擎。 代码托管 Coding 码云 文件服务 七牛 又拍云 综合云服务商 阿里云 腾讯云 百度云 新浪云 金山云 亚马逊云(AWS) 谷歌云 微软云 VPS Linode]]></content>
      <categories>
        <category>资料</category>
      </categories>
      <tags>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记（Day014：触发器下/存储过程/自定义函数）]]></title>
    <url>%2F2018%2F06%2F07%2FMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(Day014)%2F</url>
    <content type="text"><![CDATA[MySQL学习笔记（Day014：触发器下/存储过程/自定义函数）@(MySQL学习) [TOC] 一. 作业讲解 查询employees表中非基层用户的最近详细信息 关于Group By在《SQL必知必会》中提及的部分规定： GROUP BY子句中列出的每一列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。 除聚集计算语句外，SELECT语句中的每一列都必须在GROUP BY子句中给出。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647SELECT e.emp_no, CONCAT(last_name, ' ', first_name) AS name, t.title, dp.dept_name, s.salaryFROM employees e LEFT JOIN dept_manager d ON e.emp_no = d.emp_no LEFT JOIN (SELECT emp_no, title, from_date, to_date FROM titles WHERE (emp_no , from_date, to_date) IN (SELECT emp_no, MAX(from_date), MAX(to_date) FROM titles AS b GROUP BY b.emp_no)) t ON t.emp_no = e.emp_no LEFT JOIN (SELECT dept_no, emp_no, from_date, to_date FROM dept_emp WHERE (emp_no , from_date, to_date) IN (SELECT emp_no, MAX(from_date), MAX(to_date) FROM dept_emp AS b GROUP BY b.emp_no)) de ON de.emp_no = e.emp_no LEFT JOIN (SELECT emp_no, salary, from_date, to_date FROM salaries WHERE (emp_no , from_date, to_date) IN (SELECT emp_no, MAX(from_date), MAX(to_date) FROM salaries AS b GROUP BY b.emp_no)) s ON s.emp_no = e.emp_no LEFT JOIN departments dp ON dp.dept_no = de.dept_noWHERE d.emp_no IS NULL; 12345678910111213141516171819202122232425262728293031323334---- 改进的子查询语句 - 1--SELECT emp_no, title, from_date, to_dateFROM titles WHERE (emp_no , from_date, to_date) IN ( SELECT emp_no, MAX(from_date), MAX(to_date) -- 因为数据本身的问题，这里from_date和to_date都要 FROM titles AS b GROUP BY b.emp_no ) -- 这个子查询表示以emp_no分类，找到最大（最近）的from_date和to_date -- 而where条件在这个最大的基础上，过滤出我们要的title。(salary同理)---- 改进的子查询语句 - 2--SELECT emp_no, title, from_date, to_dateFROM titles AS aWHERE (from_date, to_date) = (SELECT MAX(from_date), MAX(to_date) -- 同样使用from_date和to_date FROM titles AS b WHERE a.emp_no = b.emp_no -- 这个是一个关联子查询 GROUP BY b.emp_no); Rank排名一条SQL语句 12345678910111213141516171819202122232425262728293031mysql&gt; select * from test_rank_2;+------+-------+| id | score |+------+-------+| 1 | 10 || 2 | 20 || 3 | 30 || 4 | 30 || 5 | 40 || 6 | 40 |+------+-------+6 rows in set (0.00 sec)mysql&gt; select id, score, -&gt; case -&gt; when @prev_value = score then @rank_count -&gt; when @prev_value := score then @rank_count := @rank_count + 1 -&gt; end as rank_column -&gt; from test_rank_2, (select @prev_value:=NULL, @rank_count:=0) as t -- 和RowNumber思路一样，增加一个表 -&gt; order by score desc;+------+-------+-------------+| id | score | rank_column |+------+-------+-------------+| 5 | 40 | 1 || 6 | 40 | 1 || 3 | 30 | 2 || 4 | 30 | 2 || 2 | 20 | 3 || 1 | 10 | 4 |+------+-------+-------------+6 rows in set (0.00 sec) 二. 触发器 ・ 下1. 触发器总结 触发器对性能有损耗，应当非常慎重使用； 对于事物表，触发器执行失败则整个语句回滚； Row格式主从复制，触发器不会在从库上执行； 因为从库复制的肯定是主库已经提交的数据，既然已经提交了说明触发器已经被触发过了，所以从库不会执行。 使用触发器时应防止递归执行； 1234567delimiter //create trigger trg_test before update on 'test_trigger' for each rowbegin update test_trigger set score=20 where name = old.name; -- 又触发了update操作，循环触发了end;// 2. 触发器模拟物化视图 物化视图的概念 不是基于基表的虚表 根据基表实际存在的实表 预先计算并保存耗时较多的SQL操作结果（如多表链接(join)或者group by等） 模拟物化视图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199mysql&gt; create table Orders -&gt; (order_id int unsigned not null auto_increment, -&gt; product_name varchar(30) not null, -&gt; price decimal(8,2) not null, -&gt; amount smallint not null, -&gt; primary key(order_id));Query OK, 0 rows affected (0.13 sec) -- 创建Orders表mysql&gt; insert into Orders values -&gt; (null, 'cpu', 135.5 ,1), -&gt; (null, 'memory', 48.2, 3), -&gt; (null, 'cpu', 125.6, 3), -&gt; (null, 'cpu', 105.3, 4);Query OK, 4 rows affected (0.06 sec) -- 插入测试数据Records: 4 Duplicates: 0 Warnings: 0mysql&gt; select * from Orders;+----------+--------------+--------+--------+| order_id | product_name | price | amount |+----------+--------------+--------+--------+| 1 | cpu | 135.50 | 1 || 2 | memory | 48.20 | 3 || 3 | cpu | 125.60 | 3 || 4 | cpu | 105.30 | 4 |+----------+--------------+--------+--------+4 rows in set (0.00 sec)-- 建立一个模拟物化视图的表（即用这张表来模拟物化视图）mysql&gt; create table Orders_MV -&gt; ( product_name varchar(30) not null, -&gt; price_sum decimal(8,2) not null, -&gt; amount_sum int not null, -&gt; price_avg float not null, -&gt; orders_cnt int not null, -&gt; unique index (product_name));Query OK, 0 rows affected (0.14 sec)-- 通过Orders表的数据，将测试数据初始化到Orders_MV表中mysql&gt; insert into Orders_MV -&gt; select product_name, sum(price), -&gt; sum(amount), avg(price), count(*) -&gt; from Orders -&gt; group by product_name;Query OK, 2 rows affected (0.07 sec)Records: 2 Duplicates: 0 Warnings: 0mysql&gt; select * from Orders_MV;+--------------+-----------+------------+-----------+------------+| product_name | price_sum | amount_sum | price_avg | orders_cnt |+--------------+-----------+------------+-----------+------------+| cpu | 366.40 | 8 | 122.133 | 3 || memory | 48.20 | 3 | 48.2 | 1 |+--------------+-----------+------------+-----------+------------+2 rows in set (0.00 sec)-- 在MySQL workbench中输入，比较方便delimiter //CREATE TRIGGER tgr_Orders_insert -- 创建触发器为tgr_Orders_insert AFTER INSERT ON Orders -- 触发器是INSERT类型的，且作用于Orders表 FOR EACH ROWBEGIN SET @old_price_sum := 0; -- 设置临时存放Orders_MV表(模拟物化视图)的字段的变量 SET @old_amount_sum := 0; SET @old_price_avg := 0; SET @old_orders_cnt := 0; SELECT -- select ... into ... 在更新Orders_MV之前，将Orders_MV中对应某个产品的信息写入临时变量 IFNULL(price_sum, 0), IFNULL(amount_sum, 0), IFNULL(price_avg, 0), IFNULL(orders_cnt, 0) FROM Orders_MV WHERE product_name = NEW.product_name INTO @old_price_sum , @old_amount_sum , @old_price_avg , @old_orders_cnt; SET @new_price_sum = @old_price_sum + NEW.price; -- 累加新的值 SET @new_amount_sum = @old_amount_sum + NEW.amount; SET @new_orders_cnt = @old_orders_cnt + 1; SET @new_price_avg = @new_price_sum / @new_orders_cnt ; REPLACE INTO Orders_MV VALUES(NEW.product_name, @new_price_sum, @new_amount_sum, @new_price_avg, @new_orders_cnt ); -- REPLACE 将对应的物品（唯一索引）的字段值替换new_xxx的值END;//delimiter ;mysql&gt; insert into Orders values (null, 'ssd', 299, 3);Query OK, 1 row affected (0.03 sec)mysql&gt; insert into Orders values (null, 'memory', 47.9, 5);Query OK, 1 row affected (0.05 sec)mysql&gt; select * from Orders_MV;+--------------+-----------+------------+-----------+------------+| product_name | price_sum | amount_sum | price_avg | orders_cnt |+--------------+-----------+------------+-----------+------------+| cpu | 366.40 | 8 | 122.133 | 3 || memory | 96.10 | 8 | 48.05 | 2 | -- 数量自动增加了1，价格也发生了变化| ssd | 299.00 | 3 | 299 | 1 | -- 新增加的ssd产品+--------------+-----------+------------+-----------+------------+3 rows in set (0.00 sec)---- IFNULL MySQL内建函数的演示--mysql&gt; select @test;+-------+| @test |+-------+| NULL | -- 当前会话中没有test变量+-------+1 row in set (0.00 sec)mysql&gt; select ifnull(@test, 100); -- 如果test为NULL，则ifnull返回100+--------------------+| ifnull(@test, 100) |+--------------------+| 100 | -- ifnull函数return的值是100+--------------------+1 row in set (0.00 sec)mysql&gt; select @test;+-------+| @test |+-------+| NULL | -- 但是test还是NULL+-------+1 row in set (0.00 sec)mysql&gt; set @test:=200; -- 给test变量赋值为200Query OK, 0 rows affected (0.00 sec)mysql&gt; select ifnull(@test, 100); -- 再次ifnull判断，此时test不为null，则返回test变量的值+--------------------+| ifnull(@test, 100) |+--------------------+| 200 | -- test不为null。返回test的值200+--------------------+1 row in set (0.00 sec)---- select into 用法--mysql&gt; select @id_1;+-------+| @id_1 |+-------+| NULL | -- 当前变量id_1为null +-------+1 row in set (0.00 sec)mysql&gt; select @score_1;+----------+| @score_1 |+----------+| NULL | -- 当前变量score_1为null+----------+1 row in set (0.00 sec)mysql&gt; select * from test_rank_2;+------+-------+| id | score |+------+-------+| 1 | 10 || 2 | 20 || 3 | 30 || 4 | 30 || 5 | 40 || 6 | 40 |+------+-------+6 rows in set (0.00 sec)mysql&gt; select * from test_rank_2 -&gt; where id=1 into @id_1, @score_1;-- 选择id=1的记录，将对应的id和score赋值给变量 id_1 和 score_1Query OK, 1 row affected (0.00 sec)mysql&gt; select @id_1;+-------+| @id_1 |+-------+| 1 |+-------+1 row in set (0.00 sec)mysql&gt; select @score_1;+----------+| @score_1 |+----------+| 10 |+----------+1 row in set (0.00 sec)-- 触发器对性能会有影响，相当于在一个事物中插入了其他的事物 三. 存储过程1. 存储过程介绍 存储在数据库端的一组SQL语句集； 用户可以通过存储过程名和传参多次调用的程序模块； 存储过程的特点： 使用灵活，可以使用流控语句、自定义变量等完成复杂的业务逻辑； 提高数据安全性，屏蔽应用程序直接对表的操作，易于进行审计； 减少网络传输； 提高代码维护的复杂度，实际使用需要结合业务评估； 1234567891011121314151617181920212223CREATE [DEFINER = &#123; user | CURRENT_USER &#125;] PROCEDURE sp_name ([proc_parameter[,...]]) [characteristic ...] routine_bodyproc_parameter: -- 注意，只有procedure才有in(传入),out(传出),inout(传入传出)参数，自定义函数（只有）默认就是 in。 [ IN | OUT | INOUT ] param_name type characteristic: COMMENT 'string' | LANGUAGE SQL | [NOT] DETERMINISTIC | &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125; | SQL SECURITY &#123; DEFINER | INVOKER &#125;routine_body: Valid SQL routine statement-- 删除DROP PROCEDURE procedure_name; 2. 存储过程举例与流程控制语句 流程控制语句 官方文档 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284---- IF---- 语法IF search_condition THEN statement_list [ELSEIF search_condition THEN statement_list] ... [ELSE statement_list]END IF-- 例子mysql&gt; delimiter //mysql&gt; create procedure pcd_test_1 (in param_a int) -- 创建一个 -&gt; begin -&gt; declare a int; -- delcare声明了该变量的作用域在该procedure中 -&gt; if param_a &gt; 10 then set a:=11; -&gt; elseif param_a = 10 then set a:=10; -&gt; else set a:=9; -&gt; end if; -&gt; end;//Query OK, 0 rows affected (0.01 sec)mysql&gt; select @a; -- 查看当前会话中变量a的值+------+| @a |+------+| NULL | -- 当前会话中a为NULL+------+1 row in set (0.00 sec)mysql&gt; call pcd_test_1(1);+------+| a |+------+| 9 |+------+1 row in set (0.00 sec)Query OK, 0 rows affected (0.00 sec)mysql&gt; call pcd_test_1(10);+------+| a |+------+| 10 |+------+1 row in set (0.00 sec)Query OK, 0 rows affected (0.00 sec)mysql&gt; call pcd_test_1(20);+------+| a |+------+| 11 |+------+1 row in set (0.00 sec)Query OK, 0 rows affected (0.00 sec)mysql&gt; select @a;+------+| @a |+------+| NULL | -- 使用了declare，使得procedure中a的作用域限制在了procedure内+------+1 row in set (0.00 sec)---- CASE WHEN---- CASE WHEN 语法CASE case_value WHEN when_value THEN statement_list [WHEN when_value THEN statement_list] ... [ELSE statement_list]END CASE-- 或者是CASE WHEN search_condition THEN statement_list [WHEN search_condition THEN statement_list] ... [ELSE statement_list]END CASE---- CASE WHEN 例子--mysql&gt; delimiter //mysql&gt; mysql&gt; create procedure pcd_test_2(in param_1 int) -&gt; begin -&gt; case param_1 -- 当case后面有value时，该value会和when中的when_value进行"="判断 -- 相等则执行then后面的语句，然后跳出；否则就进行下一次when的匹配 -&gt; when 2 then select 200; -&gt; when 3 then select 300; -&gt; else -&gt; begin -- 当没有匹配时，且else中没有要执行的语句 -- 则给一个begin/end的空语句； -- 或者不写else语句； -&gt; end; -&gt; end case; -&gt; end;//Query OK, 0 rows affected (0.03 sec)mysql&gt; delimiter ;mysql&gt; call pcd_test_2(1);Query OK, 0 rows affected (0.00 sec)mysql&gt; call pcd_test_2(2);+-----+| 200 |+-----+| 200 |+-----+1 row in set (0.00 sec)Query OK, 0 rows affected (0.00 sec)mysql&gt; call pcd_test_2(3);+-----+| 300 |+-----+| 300 |+-----+1 row in set (0.00 sec)Query OK, 0 rows affected (0.00 sec)-- 另外一种SQL语法请参考rank排名作业；注意when后跟的是condition---- WHILE 循环---- WHILE 语法[begin_label:] WHILE search_condition DO statement_listEND WHILE [end_label]-- WHILE举例mysql&gt; delimiter //mysql&gt; mysql&gt; create procedure pcd_test_3(in param_1 int) -&gt; begin -&gt; declare a int default 1; -&gt; while param_1 &gt; 10 do -&gt; set param_1 = param_1 - 1; -&gt; set a = a + 1; -&gt; end while; -&gt; select a; -&gt; end;//Query OK, 0 rows affected (0.01 sec)mysql&gt; delimiter ;mysql&gt; call pcd_test_3(15); -- 15 - 10 = 5；需要5次循环+------+| a |+------+| 6 | -- a + 5 = 6+------+1 row in set (0.00 sec)Query OK, 0 rows affected (0.00 sec)---- REPEAT 循环---- REPEAT 语法[begin_label:] REPEAT statement_listUNTIL search_conditionEND REPEAT [end_label]mysql&gt; delimiter //mysql&gt; create procedure pcd_test_4(in param_1 int) -&gt; begin -&gt; SET @x = 0; -- 没有使用declare，所以x是会话级别的 -&gt; REPEAT -&gt; SET @x = @x + 1; -&gt; UNTIL @x &gt; param_1 END REPEAT; -&gt; end;//Query OK, 0 rows affected (0.01 sec)mysql&gt; delimiter ;mysql&gt; call pcd_test_4(10);Query OK, 0 rows affected (0.00 sec)mysql&gt; select @x; -- x是会话级别的+------+| @x |+------+| 11 | -- 一共循环11次(10&gt;10 为False，11 &gt; 10为True，才跳出)+------+1 row in set (0.00 sec)---- loop 循环---- loop语法[begin_label:] LOOP statement_listEND LOOP [end_label]-- ITERATE 和label相结合，表示继续从label处执行-- LEAVE 和label相结合，表示从label 标记的代码段离开-- loop 例子mysql&gt; delimiter //mysql&gt; create procedure pcd_test_5(in param_1 int) -&gt; begin -&gt; test_label: loop -&gt; set param_1 := param_1 + 1; -- 参数累加 -&gt; if param_1 &lt; 10 then -- 如果累加的值小于10 -&gt; iterate test_label; -- 继续执行 标签 test_label -&gt; end if; -&gt; leave test_label; -- 如果&gt;=10则离开这个test_label(loop) -&gt; end loop test_label; -&gt; set @x = param_1; -- 设置会话级别的变量 -&gt; end;//Query OK, 0 rows affected (0.02 sec)mysql&gt; delimiter ;mysql&gt; call pcd_test_5(5); -- 5&lt;10 ，累加5次后&gt;=10为true，离开循环Query OK, 0 rows affected (0.00 sec)mysql&gt; select @x;+------+| @x |+------+| 10 | -- 累加到10的 param_1 赋值给 x, 即为10+------+1 row in set (0.00 sec)-- 老师给出的例子， 阶乘mysql&gt; create table test_proc_1(a int, b int); -- 给一个存放数据的表Query OK, 0 rows affected (0.15 sec)mysql&gt; delimiter //mysql&gt; create procedure proc_test1(in total int, out res int) -&gt; begin -&gt; declare i int; -&gt; set i := 1; -&gt; set res := 1; -&gt; if total &lt;= 0 then -&gt; set total := 1; -&gt; end if; -&gt; while i &lt;= total do -&gt; set res := res * i; -&gt; insert into test_proc_1 values(i, res); -&gt; set i := i + 1; -&gt; end while; -&gt; end;//Query OK, 0 rows affected (0.01 sec)mysql&gt; delimiter ;mysql&gt; set @res_value := 0;Query OK, 0 rows affected (0.00 sec)mysql&gt; call proc_test1(5, @res_value); -- 因为res是out变量，要预先有这个变量，这里上面设置了res_value(实参和形参不必同名)Query OK, 1 row affected (0.15 sec)mysql&gt; select @res_value;+------------+| @res_value |+------------+| 120 | -- 5的阶乘的结果是120+------------+1 row in set (0.00 sec)mysql&gt; select * from test_proc_1;+------+------+| a | b |+------+------+| 1 | 1 || 2 | 2 || 3 | 6 || 4 | 24 || 5 | 120 | -- 每次insert的结果+------+------+5 rows in set (0.00 sec) 三. 自定义函数 自定义函数和存储过程很类似，但是必须要有返回值； 与内置的函数(sum(), max()等)使用方法类似 select fun(val); select * from t where col= fun(val); 自定义函数可能在遍历每条记录中使用； 123456789101112131415161718192021222324CREATE [DEFINER = &#123; user | CURRENT_USER &#125;] FUNCTION sp_name ([func_parameter[,...]]) RETURNS type -- 必须有返回值 [characteristic ...] routine_body func_parameter: param_name typetype: Any valid MySQL data typecharacteristic: COMMENT 'string' | LANGUAGE SQL | [NOT] DETERMINISTIC | &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125; | SQL SECURITY &#123; DEFINER | INVOKER &#125;routine_body: Valid SQL routine statement -- 删除DROP FUNCTION fun_name; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687-- 老师给的例子，还是阶乘，用自定义函数的方式mysql&gt; delimiter //mysql&gt; mysql&gt; create function fun_test_1(total int) -&gt; returns int -&gt; begin -&gt; declare i int; -&gt; declare res int; -&gt; set i := 1; -&gt; set res := 1; -&gt; if total &lt;= 0 then -&gt; set total := 1; -&gt; end if; -&gt; while i &lt;= total do -&gt; set res := res * i; -&gt; set i := i + 1; -&gt; end while; -&gt; return res; -&gt; end;//ERROR 1418 (HY000): This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled (you *might* want to use the less safe log_bin_trust_function_creators variable)-- 报错，提示因为函的声明中没有"DETERMINISTIC, NO SQL, or READS SQL DATA"等关键字 ，需要使用打开参数 log_bin_trust_function_creators-- 解决方法，set global log_bin_trust_function_creators=1; 开启该选项可能会引起主从服务器不一致-- 或者 增加 上述相应功能的关键字-- 使用 deterministic 关键字-- 当你声明一个函数的返回是确定性的，则必须显示的使用deterministic关键字，默认是 no deterministic的mysql&gt; delimiter //mysql&gt; create function fun_test_1(total int) -&gt; returns int deterministic -- 这个只是告诉MySQL我这个函数是否会改变数据 -- 即使我下面使用了insert，update等DML语句，MySQL不会检查 -- 函数是否会改变数据，完全依赖创建函数的用户去指定的关键字 -- 而非真的是否有修改数据 -- 只是声明，而非约束 -&gt; begin -&gt; declare i int; -&gt; declare res int; -&gt; set i := 1; -&gt; set res := 1; -&gt; if total &lt;= 0 then -&gt; set total := 1; -&gt; end if; -&gt; while i &lt;= total do -&gt; set res := res * i; -&gt; insert into test_proc_1 values(i, res); -- 在自定义函数中，同样可以使用sql -- 并且该SQL是insert，其实和deterministic违背。 -&gt; set i := i + 1; -&gt; end while; -&gt; return res; -&gt; end;//Query OK, 0 rows affected (0.01 sec)mysql&gt; delimiter ;mysql&gt; truncate table test_proc_1;Query OK, 0 rows affected (0.11 sec)mysql&gt; select fun_test_1(6); -- return了6的阶乘，720+---------------+| fun_test_1(6) |+---------------+| 720 |+---------------+1 row in set (0.02 sec)mysql&gt; select * from test_proc_1; +------+------+| a | b |+------+------+| 1 | 1 || 2 | 2 || 3 | 6 || 4 | 24 || 5 | 120 || 6 | 720 | -- 使用了insert语句进行插入阶乘的历史记录+------+------+6 rows in set (0.00 sec)-- 关键字简单说明-- DETERMINISTIC ： 当给定相同的输入，产生确定的结果-- NOT DETERMINISTIC ： 默认值，认为产生的结果是不确定的-- READS SQL DATA ： 只是读取SQL数据-- MODIFIES SQL DATA ： 会修改数据-- NO SQL ： 没有SQL遇见-- CONTAINS SQL ： 包含SQL语句，但是没有读写语句，理论有select now()等 原文链接部分原文：By default, for a CREATE FUNCTION statement to be accepted, at least one of DETERMINISTIC, NO SQL, or READS SQL DATA must be specified explicitly. Otherwise an error occurs:默认情况下，在创建自定义函数时，必须显示的指定关键字DETERMINISTIC, NO SQL, 或者是 READS SQL DATA中的至少一个(可以多个)，否则就会有如下错误 ERROR 1418 (HY000): This function has none of DETERMINISTIC, NO SQL,or READS SQL DATA in its declaration and binary logging is enabled (you might want to use the less safe log_bin_trust_function_creatorsvariable) 网上参考资料1网上参考资料2]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记（Day013：作业讲解一/Rank/视图/UNION/触发器）]]></title>
    <url>%2F2018%2F06%2F06%2FMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(Day013)%2F</url>
    <content type="text"><![CDATA[MySQL学习笔记（Day013：作业讲解一/Rank/视图/UNION/触发器）@(MySQL学习) [TOC] 一. 作业讲解 查询employees表中非基层用户的最近详细信息 老师的讲解的版本中存在问题，重新作为作业 统计dbt3库下orders每周每个客户的订单数量 思路 找到订单中最小周(week)之前的一周的周一，这里进行了简化，使用了1970-01-05作为周一标记，作为起始(start) 12345678[root@MyServer ~]&gt; cal 1 1970 January 1970 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 # 1970-01-05 刚好是周一，用1月12号，19号，26号等也是可以的11 12 13 14 15 16 1718 19 20 21 22 23 2425 26 27 28 29 30 31 在起始条件周一（start)的基础上 增加6天时间，就是周日，即为一周的结束标记(end) 通过对start（周一）、end（周日）以及o_custkey进行分组，使用count(o_orderkey)得到对应的数量 SQL语句 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146-- 最终结果select o_custkey,ADDDATE('1970-01-05', INTERVAL FLOOR(DATEDIFF(o_orderdate, '1970-01-05')/7)*7 Day) as start,ADDDATE('1970-01-05', INTERVAL FLOOR(DATEDIFF(o_orderdate, '1970-01-05')/7)*7 + 6 Day) as end,count(o_orderkey) as total from dbt3.orders group by o_custkey, start, end;-- DATEDIFF(o_orderdate, '1970-01-05')mysql&gt; select datediff('1971-01-01', '1970-01-05'); -- 随意取一个1971-01-01，作为演示+--------------------------------------+| datediff('1971-01-01', '1970-01-05') |+--------------------------------------+| 361 | -- 1971-01-01 减去 1970-01-5 为361天+--------------------------------------+1 row in set (0.00 sec) mysql&gt; select datediff('1971-01-01', '1970-01-05') / 7; -- 求周数+------------------------------------------+| datediff('1971-01-01', '1970-01-05') / 7 |+------------------------------------------+| 51.5714 | -- 相隔51.5714周+------------------------------------------+1 row in set (0.00 sec)-- FLOOR 和 ROUND函数-- FLOOR(arg)是返回一个不大于arg的最大整数，其实就是取整mysql&gt; select floor(5.4);+------------+| floor(5.4) |+------------+| 5 |+------------+1 row in set (0.00 sec)mysql&gt; select floor(5.5);+------------+| floor(5.5) |+------------+| 5 |+------------+1 row in set (0.00 sec)mysql&gt; select floor(5.6);+------------+| floor(5.6) |+------------+| 5 |+------------+1 row in set (0.00 sec)-- ROUND(X, D) 返回值是对数字X保留到小數点后D位，D默认为0，结果符合四舍五入原则；如果D为负数，则保留小数点左边（整数）的位数mysql&gt; select round(5.4); -- 默认D为0，四舍五入+------------+| round(5.4) |+------------+| 5 |+------------+1 row in set (0.00 sec)mysql&gt; select round(5.5); -- 默认D为0，四舍五入+------------+| round(5.5) |+------------+| 6 |+------------+1 row in set (0.00 sec)mysql&gt; select round(5.123, 1); -- 设D为1，保留小数点右边1为，四舍五入，不进位+-----------------+| round(5.123, 1) |+-----------------+| 5.1 |+-----------------+1 row in set (0.00 sec)mysql&gt; select round(5.163, 1); -- 设D为1，保留小数点右边1为，四舍五入，进位+-----------------+| round(5.163, 1) |+-----------------+| 5.2 |+-----------------+1 row in set (0.00 sec) mysql&gt; select round(524.163, -1); -- 保留小数点左边1位，不进位+--------------------+| round(524.163, -1) |+--------------------+| 520 |+--------------------+1 row in set (0.00 sec)mysql&gt; select round(524.163, -2); -- 保留小数点左边2位, 不进位+--------------------+| round(524.163, -2) |+--------------------+| 500 |+--------------------+1 row in set (0.00 sec)mysql&gt; select round(554.163, -2); -- 保留小数点左边2位, 进位+--------------------+| round(554.163, -2) |+--------------------+| 600 |+--------------------+1 row in set (0.00 sec)-- 所以这里使用floor函数取整， 超过一周且不满一周的则落在start 和 end 中间mysql&gt; select floor(datediff('1971-01-01', '1970-01-05') / 7);+-------------------------------------------------+| floor(datediff('1971-01-01', '1970-01-05') / 7) |+-------------------------------------------------+| 51 | -- 取整为51周+-------------------------------------------------+1 row in set (0.00 sec)mysql&gt; select floor(datediff('1971-01-01', '1970-01-05') / 7) * 7;+-----------------------------------------------------+| floor(datediff('1971-01-01', '1970-01-05') / 7) * 7 |+-----------------------------------------------------+| 357 | -- 乘以7，得出357天差值+-----------------------------------------------------+1 row in set (0.00 sec)mysql&gt; select adddate('1970-01-05', interval floor(datediff('1971-01-01', '1970-01-05')/7)*7 day) as Monday_start; -- 使用adddate函数，在1970-01-05(周一)的基础上，增加357天（51周），得到的值1970-12-28也是周一，标记为start+--------------+| Monday_start |+--------------+| 1970-12-28 | -- 1970-12-28（周一），而传入的值1971-01-01是该周的周五+--------------+1 row in set (0.00 sec)-- 以同样的方法得到周日mysql&gt; select adddate('1970-01-05', interval floor(datediff('1971-01-01', '1970-01-05')/7)*7 + 6 day) as Sunday_end;+------------+| Sunday_end |+------------+| 1971-01-03 |+------------+1 row in set (0.00 sec)-- 通过以上的周一和周日的计算，即可求出1971-01-01这天所在的一周，得出start（周一）和end（周日）-- 然后对start和end以及o_custkey做分组操作，并通过count(o_orderkey)得到分组的定单量 使用子查询实现RowNumber 思路 假设当前在第N行记录，通过主键emp_no遍历有多少行的记录小于等于当前行,即为当前行的行数 SQL语句 12345678910111213141516171819202122232425262728293031323334SELECT (SELECT COUNT(1) FROM employees b WHERE b.emp_no &lt;= a.emp_no ) AS row_number,emp_no,CONCAT(last_name," ",first_name) name,gender,hire_dateFROM employees a ORDER BY emp_no LIMIT 10;-- 假设当前在第5行mysql&gt; select b.emp_no from employees.employees as b order by b.emp_no limit 5;+--------+| emp_no |+--------+| 10001 || 10002 || 10003 || 10004 || 10005 | -- 第5行的emp_no是10005+--------+5 rows in set (0.00 sec)mysql&gt; select count(*) from employees.employees as b where b.emp_no &lt;= 10005 order by b.emp_no;查找小于等于5的行数有几行+----------+| count(*) |+----------+| 5 | -- 小于等于10005的记录有5行，则5就是10005该行记录的行号+----------+1 row in set (0.00 sec)-- 将该子查询的结果即可作为RowNumber-- 但是该子查询的效率较低。不推荐使用。-- 推荐Day012中提及的自定义变量方式SELECT @a:=@a+1 AS row_number, emp_no,CONCAT(last_name," ",first_name) name,gender,hire_date FROM employees,(SELECT @a:=0) AS a LIMIT 10; 二. Rank 给出不同的用户的分数，然后根据分数计算排名1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859mysql&gt; create table test_rank(id int, score int);Query OK, 0 rows affected (0.16 sec)mysql&gt; insert into test_rank values(1, 10), (2, 20), (3, 30), (4, 30), (5, 40), (6, 40);Query OK, 6 rows affected (0.05 sec)Records: 6 Duplicates: 0 Warnings: 0mysql&gt; select * from test_rank;+------+-------+| id | score |+------+-------+| 1 | 10 || 2 | 20 || 3 | 30 || 4 | 30 || 5 | 40 || 6 | 40 |+------+-------+6 rows in set (0.00 sec)mysql&gt; set @prev_value := NULL; -- 假设比较到第N行，设置一个变量prev_value用于存放第N-1行score的分数 -- 用于比较第N行的score和第N-1行的score -- prev_value可以理解为 是临时保存第N-1行的score的变量Query OK, 0 rows affected (0.00 sec)mysql&gt; set @rank_count := 0; -- 用于存放当前的排名Query OK, 0 rows affected (0.00 sec)mysql&gt; select id, score, -&gt; case -&gt; when @prev_value = score then @rank_count -- 相等则prev_value不变， 并返回rank_count（第一次为NULL，不会相等，所以跳转到下一个when语句） -&gt; when @prev_value := score then @rank_count := @rank_count + 1 -- 不等，则第N行的score赋值(:=)给prev_value。且rank_count增加1 -&gt; end as rank_column -- case 开始的，end结尾 -&gt; from test_rank -&gt; order by score desc;+------+-------+-------------+| id | score | rank_column |+------+-------+-------------+| 5 | 40 | 1 || 6 | 40 | 1 || 3 | 30 | 2 || 4 | 30 | 2 || 2 | 20 | 3 || 1 | 10 | 4 |+------+-------+-------------+6 rows in set (0.00 sec)-- case -- when [condition_1] then [do_something_1] -- when [condition_2] then [do_something_2] -- end-- 语法：如果 condition_1条件满足，则执行 do_something_1 然后就跳出,不会执行condition_2;-- 如果 condition_1条件不满足，则继续执行到 condition_2。以此类推。---- 作业：使用一条语句写出Rank-- 三. 视图 官方文档 创建视图 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798---- 创建视图--mysql&gt; create view view_rank as select * from test_rank; -- 针对上面的test_rank创建一个视图Query OK, 0 rows affected (0.03 sec)-- 也可以对select结果增加条件进行过滤后，再创建视图mysql&gt; show create table test_rank\G*************************** 1. row *************************** Table: test_rankCreate Table: CREATE TABLE `test_rank` ( -- 得到的是表结构 `id` int(11) DEFAULT NULL, `score` int(11) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb41 row in set (0.00 sec)mysql&gt; show create table view_rank\G -- 他是以一张表的形式存在的，可通过show tables看到*************************** 1. row *************************** View: view_rank Create View: CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `view_rank` AS select `test_rank`.`id` AS `id`,`test_rank`.`score` AS `score` from `test_rank` -- 和真正的表不同的是，这里show出来的是视图的定义character_set_client: utf8collation_connection: utf8_general_ci1 row in set (0.00 sec)mysql&gt; select * from view_rank; -- 可以直接查询该视图得结果+------+-------+| id | score |+------+-------+| 1 | 10 || 2 | 20 || 3 | 30 || 4 | 30 || 5 | 40 || 6 | 40 |+------+-------+6 rows in set (0.00 sec)-- 视图的作用是，可以对开发人员是透明的，可以隐藏部分关键的列-- 视图在mysql是虚拟表。根据视图的定义，还是取执行定义中的select语句。-- 只开放部分列mysql&gt; create view view_rank_1 as select id from test_rank; -- 只开放id列Query OK, 0 rows affected (0.04 sec)mysql&gt; select * from view_rank_1; -- 即使 select * ，也只能看到id列，具有隐藏原来表中部分列的功能 +------+| id |+------+| 1 || 2 || 3 || 4 || 5 || 6 |+------+6 rows in set (0.00 sec)-- 不要取用select * from 去创建视图，因为mysql会把*逐个解析成列。-- 当原来的表结构发生变化时，视图的表结构是不会发生变化的，视图在创建的瞬间，便确定了结构。-- 比如，当你alter原来的表 增加列(add columns)时,再去查询该视图,新增加的列是不存在的。mysql&gt; alter table test_rank add column c int default 0; -- 增加一列名字为c，默认值为0Query OK, 0 rows affected (0.30 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; select * from test_rank; -- 查询原表，新的列c出现了+------+-------+------+| id | score | c |+------+-------+------+| 1 | 10 | 0 || 2 | 20 | 0 || 3 | 30 | 0 || 4 | 30 | 0 || 5 | 40 | 0 || 6 | 40 | 0 |+------+-------+------+6 rows in set (0.00 sec)mysql&gt; select * from view_rank; -- 尽管view_rank用select * 创建，但当时没有列c，所以无法得到c列的值+------+-------+| id | score |+------+-------+| 1 | 10 || 2 | 20 || 3 | 30 || 4 | 30 || 5 | 40 || 6 | 40 |+------+-------+6 rows in set (0.00 sec)-- 注意：mysql中的视图都是虚拟表。不像Oracle可以物化成真实存在的表。-- 每次查询视图，实际上还是去查询的原来的表，只是查询的规则是在视图创建时经过定义的。 视图的算法视图的算法(ALGORITHM)有三种方式： UNDEFINED 默认方式，由MySQL来判断使用下面的哪种算法 MERGE ： 每次通过物理表查询得到结果，把结果merge(合并)起来返回 TEMPTABLE ： 产生一张临时表，把数据放入临时表后，客户端再去临时表取数据（不会缓存） TEMPTABLE 特点：即使访问条件一样，第二次查询还是会去读取物理表中的内容，并重新生成一张临时表,并不会取缓存之前的表。（临时表是Memory存储引擎，默认放内存，超过配置大小放磁盘） 当查询有一个较大的结果集时，使用TEMPTABLE可以快速的结束对该物理表的访问，从而可以快速释放这张物理表上占用的资源。然后客户端可以对临时表上的数据做一些耗时的操作，而不影响原来的物理表。 **所以一般我们使用`UNDEFINED`，由MySQL自己去判断** 四. UNION UNION 的作用是将两个查询的结果集进行合并。 UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔。 UNION中的每个查询必须包含相同的列（类型相同或可以隐式转换）、表达式或聚集函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778mysql&gt; create table test_union_1(a int, b int);Query OK, 0 rows affected (0.18 sec)mysql&gt; create table test_union_2(a int, c int); Query OK, 0 rows affected (0.15 sec)mysql&gt; insert into test_union_1 values(1, 2), (3, 4), (5, 6), (10, 20);Query OK, 4 rows affected (0.06 sec)Records: 4 Duplicates: 0 Warnings: 0mysql&gt; insert into test_union_2 values(10, 20), (30, 40), (50, 60); Query OK, 3 rows affected (0.03 sec)Records: 3 Duplicates: 0 Warnings: 0mysql&gt; select * from test_union_1;+------+------+| a | b |+------+------+| 1 | 2 || 3 | 4 || 5 | 6 || 10 | 20 | -- test_union_1 中的10, 20+------+------+4 rows in set (0.00 sec)mysql&gt; select * from test_union_2;+------+------+| a | c |+------+------+| 10 | 20 | -- test_union_2 中的10, 20| 30 | 40 || 50 | 60 | +------+------+3 rows in set (0.00 sec)mysql&gt; select a, b as t from test_union_1 -&gt; union -&gt; select * from test_union_2;+------+------+| a | t |+------+------+| 1 | 2 || 3 | 4 || 5 | 6 || 10 | 20 | -- 只出现了一次 10, 20，union会去重| 30 | 40 || 50 | 60 |+------+------+6 rows in set (0.00 sec)mysql&gt; select a, b as t from test_union_1 -&gt; union all -- 使用 union all 可以不去重 -&gt; select * from test_union_2;+------+------+| a | t |+------+------+| 1 | 2 || 3 | 4 || 5 | 6 || 10 | 20 | -- test_union_1 中的10, 20| 10 | 20 | -- test_union_2 中的10, 20| 30 | 40 || 50 | 60 |+------+------+7 rows in set (0.00 sec)mysql&gt; select a, b as t from test_union_1 where a &gt; 2 -&gt; union -&gt; select * from test_union_2 where c &gt; 50; -- 使用where过滤也可以 +------+------+| a | t |+------+------+| 3 | 4 || 5 | 6 || 10 | 20 || 50 | 60 |+------+------+4 rows in set (0.00 sec) 如果知道数据本身具有唯一性，没有重复，则建议使用union all，因为union会做去重操作，性能会比union all要低 五. 触发器 官方文档 定义 触发器的对象是表，当表上出现特定的事件时触发该程序的执行 触发器的类型 UPDATE update 操作 DELETE delete 操作 replace 操作 注意：drop，truncate等DDL操作不会触发DELETE INSERT insert 操作 load data 操作 replace 操作 注意，replace操作会触发两次，一次是UPDATE类型的触发器，一次是INSERT类型的触发器MySQL 5.6版本同一个类型的触发器只能有一个(针对一个表)MySQL 5.7允许多个同一类型的触发器 注意：触发器只触发DML(Data Manipulation Language)操作，不会触发DDL(Data Definition Language)操作（create,drop等操作） 创建触发器 12345678910111213CREATE [DEFINER = &#123; user | CURRENT_USER &#125;] TRIGGER trigger_name -- 触发器名字 trigger_time trigger_event -- 触发时间和事件 ON tbl_name FOR EACH ROW [trigger_order] trigger_bodytrigger_time: &#123; BEFORE | AFTER &#125; -- 事件之前还是之后触发trigger_event: &#123; INSERT | UPDATE | DELETE &#125; -- 三个类型trigger_order: &#123; FOLLOWS | PRECEDES &#125; other_trigger_name 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647mysql&gt; create table test_trigger_1 ( -&gt; name varchar(10), -&gt; score int(10), -&gt; primary key (name));Query OK, 0 rows affected (0.14 sec) mysql&gt; delimiter // -- 将语句分隔符定义成 // （原来是';'） mysql&gt; create trigger trg_upd_score -- 定义触发器名字 -&gt; before update on test_trigger_1 -- 作用在test_trigger_1 更新(update)之前(before) -&gt; for each row -- 每行 -&gt; begin -- 开始定义 -&gt; if new.score &lt; 0 then -- 如果新值小于0 -&gt; set new.score=0; -- 则设置成0 -&gt; elseif new.score &gt; 100 then -- 如果新值大于100 -&gt; set new.score = 100; -- 则设置成100 -&gt; end if; -- begin对应的 结束 -&gt; end;// -- 结束，使用新定义的 '//' 结尾 Query OK, 0 rows affected (0.03 sec)mysql&gt; delimiter ; -- 恢复 ';' 结束符-- new.col : 表示更新以后的值-- old.col : 表示更新以前的值(只读)mysql&gt; insert into test_trigger_1 values ("tom", 200); -- 插入新值Query OK, 1 row affected (0.04 sec)mysql&gt; select * from test_trigger_1;+------+-------+| name | score |+------+-------+| tom | 200 | -- 没改成100，因为定义的是update，而执行的是insert+------+-------+1 row in set (0.00 sec)mysql&gt; update test_trigger_1 -&gt; set score=300 where name='tom'; -- 改成300Query OK, 0 rows affected (0.00 sec)Rows matched: 1 Changed: 0 Warnings: 0mysql&gt; select * from test_trigger_1;+------+-------+| name | score |+------+-------+| tom | 100 | -- 通过触发器的设置，大于100的值被修改成100+------+-------+1 row in set (0.00 sec)]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记（Day012：子查询/INSERT/UPDATE/DELETE/REPLACE）]]></title>
    <url>%2F2018%2F06%2F04%2FMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(Day012)%2F</url>
    <content type="text"><![CDATA[MySQL学习笔记（Day012：子查询/INSERT/UPDATE/DELETE/REPLACE）@(MySQL学习) [TOC] 一. 子查询 子查询就是指在一个select语句中嵌套另一个select语句。同时，子查询必须包含括号。MySQL 5.6.x 版本之前，MySQL的子查询性能较差，但是从5.6开始，不存在性能差的问题。 1select a from t1 where a &gt; any(select a from t2); select a from t1 是外部查询(outer query) (select a from t2) 是子查询 一般说来，子查询嵌套于外部查询中，可以将两个或两个以上的子查询进行嵌套 1. 子查询的使用1.1. ANY / SOME如果外部查询的列的结果和子查询的列的结果比较得到为True的话，则返回比较值为True的（外查询）的记录 12345678910111213141516171819202122232425262728293031323334353637383940414243444546mysql&gt; create table t1 (a int);Query OK, 0 rows affected (0.15 sec)mysql&gt; create table t2 (a int); Query OK, 0 rows affected (0.14 sec)mysql&gt; insert into t1 values(10),(4);Query OK, 2 rows affected (0.02 sec)Records: 2 Duplicates: 0 Warnings: 0mysql&gt; insert into t2 values(12),(13),(5);Query OK, 3 rows affected (0.03 sec)Records: 3 Duplicates: 0 Warnings: 0mysql&gt; select a from t1;+------+| a |+------+| 10 || 4 |+------+2 rows in set (0.00 sec)mysql&gt; select * from t2;+------+| a |+------+| 12 | -- t1中10，4比12小| 13 | -- t1中10，4比13小| 5 | -- t1中10比5大，4比5小+------+3 rows in set (0.00 sec)mysql&gt; select a from t1 -&gt; where a &gt; any -&gt; (select a from t2); -- 返回(12，13，4) -- t1中a列的值，只要大于(12,13,4)中任意一值 -- 即t1.a &gt; t2.a为True，则返回对应的t1.a+------+| a |+------+| 10 | -- 10 比 5 大为True，则返回该值，4比t2中所有的a值小，为False+------+1 row in set (0.00 sec)-- 这个查询可以解释为，t1表内a列的值 大于 t2表中a列的任意(any)一个值（t1.a &gt; any(t2.a) == true）,则返回t1.a的记录 ANY关键词必须与一个比较操作符一起使用： =, &gt;, &lt;, &gt;=, &lt;=, &lt;&gt; (这个是!=的意思) 子查询中SOME和ANY是同一个意思 1.2. INin是ANY的一种特殊情况：&quot;in&quot; equals &quot;= any&quot; 123456789101112131415161718mysql&gt; insert into t1 values(5); -- 向t1中插入一个t2中存在的值 5Query OK, 1 row affected (0.03 sec)mysql&gt; select a from t1 where a = any(select a from t2); -- t1.a==t2.a 的只有5+------+| a |+------+| 5 |+------+1 row in set (0.00 sec)mysql&gt; select a from t1 where a in (select a from t2); -- in的结果等同于 =any 的结果+------+| a |+------+| 5 |+------+1 row in set (0.00 sec) select a from s1 where a in (select a in t2);是用的比较多的一种语法 1.3. ALL如果外部查询的列的结果和子查询的列的所有结果比较得到为True的话，则返回比较值为True的（外查询）的记录123456789101112131415161718192021mysql&gt; truncate t1; -- 清空t1Query OK, 0 rows affected (0.07 sec)mysql&gt; truncate t2; -- 清空t2Query OK, 0 rows affected (0.10 sec)mysql&gt; insert into t1 values(10),(4);Query OK, 2 rows affected (0.02 sec)Records: 2 Duplicates: 0 Warnings: 0mysql&gt; insert into t2 values(5),(4),(3); Query OK, 3 rows affected (0.03 sec)Records: 3 Duplicates: 0 Warnings: 0mysql&gt; select a from t1 where a &gt; all(select a from t2);+------+| a |+------+| 10 | -- (10 &gt; 5, 4, 3 为 True) 而 (4 &gt;5, 4, 3 为 False)+------+1 row in set (0.00 sec) ALL关键词必须与一个比较操作符一起使用NOT IN 是 &lt;&gt; ALL的别名 2. 子查询的分类 独立子查询 不依赖外部查询而运行的子查询1234567mysql&gt; select a from t1 where a in (1,2,3,4,5);+------+| a |+------+| 4 | +------+1 row in set (0.00 sec) 相关子查询 引用了外部查询列的子查询12345678-- 在这个例子中，子查询中使用到了外部的列t2.a mysql&gt; select a from t1 where a in (select * from t2 where t1.a = t2.a);+------+| a |+------+| 4 |+------+1 row in set (0.00 sec) 3. 子查询的优化 MySQL5.6之前在MySQL5.6之前，优化器会把子查询重写成exists的形式12345select a from t1 where a in (select a from t2); -- 这个是一条独立的子查询，时间复杂度 O(M+N)---- 经过优化器重写后--select a from t1 where exists (select 1 from t2 where t1.a = t2.a); -- 这是相关子查询，复杂度O(M*N + M) 所以在MySQL 5.6之前，部分的子查询需要重写成join的形式 （注意表的大小）1234567mysql&gt; select t1.a from t1 join t2 on t1.a = t2.a;+------+| a |+------+| 4 |+------+1 row in set (0.00 sec) MySQL 5.6之后在MySQL 5.6之后，优化器不会将子查询重写成exists的形式，而是自动优化，性能有了大幅提升 可通过explain extended来查看子查询优化的结果。由于explain还未讲到，该部分暂时跳过 4. 包含NULL值的NOT IN1234567mysql&gt; select null in ('a', 'b', null);+--------------------------+| null in ('a', 'b', null) |+--------------------------+| NULL |+--------------------------+1 row in set (0.00 sec) MySQL数据库的比较操作，除了返回1(True), 0(False)之外，还会返回NULLNULL和NULL的比较，返回的还是NULL 12345678910111213141516171819202122232425262728293031mysql&gt; select null not in ('a', 'b', null); +------------------------------+| null not in ('a', 'b', null) |+------------------------------+| NULL | -- null不在('a', 'b', null)中，返回的还是null，因为有null和null的比较+------------------------------+1 row in set (0.00 sec)mysql&gt; select 'a' not in ('a', 'b', null); +-----------------------------+| 'a' not in ('a', 'b', null) |+-----------------------------+| 0 | -- a 不在 ('a', 'b', null)中，返回0,即False+-----------------------------+1 row in set (0.00 sec)mysql&gt; select 'c' not in ('a', 'b');+-----------------------+| 'c' not in ('a', 'b') |+-----------------------+| 1 | -- 这个返回值可以理解 'c'不在('a', 'b')中，返回1，即为True+-----------------------+1 row in set (0.00 sec)mysql&gt; select 'c' not in ('a', 'b', null); +-----------------------------+| 'c' not in ('a', 'b', null) |+-----------------------------+| NULL | -- 理论上应该是返回1，即True的。但是包含了null值。则返回null+-----------------------------+1 row in set (0.00 sec) 对于包含了NULL值的IN操作，总是返回True或者NULLNOT IN返回NOT True (False)或者NOT NULL (NULL) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677---- SQL语句一 使用 EXISTS--select customerid, companyname from customers as A where country = 'Spain' and not exists ( select * from orders as B where A.customerid = B.customerid ); ---- SQL语句二 使用 IN--select customerid, companyname from customers as A where country = 'Spain' and customerid not in (select customerid from orders); ------- 当结果集合中没有NULL值时，上述两条SQL语句查询的结果是一致的 --------- 插入一个NULL值--insert into orders(orderid) values (null);------- SQL语句1 : 返回和之前一致-- SQL语句2 : 返回为空表，因为子查询返回的结果集中存在NULL值。not in null 永远返回False或者NULL-- 此时 where (country = 'Spain' and (False or NULL)) 为 False OR NULL，条件永远不匹配--------- SQL语句2 改写后--select customerid, companyname from customers as A where country = 'Spain' and customerid not in (select customerid from orders where customerid is not null); -- 增加这个过滤条件，使用is not，而不是&lt;&gt;---- 和 null比较，使用is和is not， 而不是 = 和 &lt;&gt;--mysql&gt; select null = null; +-------------+| null = null |+-------------+| NULL |+-------------+1 row in set (0.00 sec)mysql&gt; select null &lt;&gt; null;+--------------+| null &lt;&gt; null |+--------------+| NULL |+--------------+1 row in set (0.00 sec)mysql&gt; select null is null; +--------------+| null is null |+--------------+| 1 | -- 返回 True+--------------+1 row in set (0.00 sec)mysql&gt; select null is not null;+-------------------+| null is not null |+-------------------+| 0 | -- 返回 False+-------------------+1 row in set (0.00 sec) EXISTS不管返回值是什么，而是看是否有行返回，所以EXISTS中子查询都是select *、select 1等，因为只关心返回是否有行（结果集） 二. INSERT 官方文档 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104mysql&gt; insert into t1 values(1); -- 插入一个值Query OK, 1 row affected (0.03 sec)mysql&gt; insert into t1 values(2),(3),(-1); -- 插入多个值，MySQL独有Query OK, 3 rows affected (0.03 sec)Records: 3 Duplicates: 0 Warnings: 0mysql&gt; insert into t1 select 8; -- insert XXX select XXX 语法，MySQ独有Query OK, 1 row affected (0.02 sec)Records: 1 Duplicates: 0 Warnings: 0mysql&gt; create table t3 (a int, b int); -- 有多个列Query OK, 0 rows affected (0.15 sec)mysql&gt; insert into t3 select 8; -- 没有指定列，报错ERROR 1136 (21S01): Column count doesn't match value count at row 1mysql&gt; insert into t3(a) select 8; -- 指定列aQuery OK, 1 row affected (0.04 sec)Records: 1 Duplicates: 0 Warnings: 0mysql&gt; insert into t3 select 8, 9; -- 不指定列，但是插入值匹配列的个数和类型Query OK, 1 row affected (0.03 sec)Records: 1 Duplicates: 0 Warnings: 0mysql&gt; select * from t3;+------+------+| a | b |+------+------+| 8 | NULL || 8 | 9 |+------+------+2 rows in set (0.00 sec)mysql&gt; insert into t3(b) select a from t2; -- 从t2表中查询数据并插入到t3(a)中，注意指定列Query OK, 3 rows affected (0.03 sec)Records: 3 Duplicates: 0 Warnings: 0mysql&gt; select * from t3;+------+------+| a | b |+------+------+| 8 | NULL || 8 | 9 || NULL | 5 || NULL | 4 || NULL | 3 |+------+------+5 rows in set (0.00 sec)---- 如果想快速增长表格中的数据，可以使用如下方法，使得数据成倍增长--mysql&gt; insert into t3 select * from t3;Query OK, 5 rows affected (0.03 sec) -- 插入了5列Records: 5 Duplicates: 0 Warnings: 0mysql&gt; select * from t3; +------+------+| a | b |+------+------+| 8 | NULL || 8 | 9 || NULL | 5 || NULL | 4 || NULL | 3 || 8 | NULL || 8 | 9 || NULL | 5 || NULL | 4 || NULL | 3 |+------+------+10 rows in set (0.00 sec)mysql&gt; insert into t3 select * from t3;Query OK, 10 rows affected (0.03 sec) -- 插入了10列，成倍增长Records: 10 Duplicates: 0 Warnings: 0mysql&gt; select * from t3; +------+------+| a | b |+------+------+| 8 | NULL || 8 | 9 || NULL | 5 || NULL | 4 || NULL | 3 || 8 | NULL || 8 | 9 || NULL | 5 || NULL | 4 || NULL | 3 || 8 | NULL || 8 | 9 || NULL | 5 || NULL | 4 || NULL | 3 || 8 | NULL || 8 | 9 || NULL | 5 || NULL | 4 || NULL | 3 |+------+------+20 rows in set (0.00 sec) 三. DELETE 官方文档 1234567891011121314151617181920212223mysql&gt; delete from t3 where a is null; -- 根据过滤条件删除Query OK, 12 rows affected (0.03 sec)mysql&gt; select * from t3; +------+------+| a | b |+------+------+| 8 | NULL || 8 | 9 || 8 | NULL || 8 | 9 || 8 | NULL || 8 | 9 || 8 | NULL || 8 | 9 |+------+------+8 rows in set (0.00 sec)mysql&gt; delete from t3; -- 删除整个表Query OK, 8 rows affected (0.03 sec)mysql&gt; select * from t3;Empty set (0.00 sec) 四. UPDATE 官方文档 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869mysql&gt; insert into t3 select 1,2;Query OK, 1 row affected (0.03 sec)Records: 1 Duplicates: 0 Warnings: 0mysql&gt; select * from t3;+------+------+| a | b |+------+------+| 1 | 2 |+------+------+1 row in set (0.00 sec)mysql&gt; update t3 set a=10 where a=1;Query OK, 1 row affected (0.03 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from t3;+------+------+| a | b |+------+------+| 10 | 2 |+------+------+1 row in set (0.00 sec)---- 关联后更新--mysql&gt; select * from t1;+------+| a |+------+| 10 || 4 | -- 和t2中的4相等| 1 || 2 || 3 | -- 和t2中的3相等| -1 || 8 |+------+7 rows in set (0.00 sec)mysql&gt; select * from t2;+------+| a |+------+| 5 || 4 | -- 和t1中的4相等| 3 | -- 和t1中的3相等+------+3 rows in set (0.00 sec)mysql&gt; update t1 join t2 on t1.a = t2.a set t1.a=100; -- 先得到t1.a=t2.a的结果集 -- 然后将结果集中的t1.a设置为100Query OK, 2 rows affected (0.03 sec)Rows matched: 2 Changed: 2 Warnings: 0mysql&gt; select * from t1;+------+| a |+------+| 10 || 100 | -- 该行被更新成100| 1 || 2 || 100 | -- 该行被更新成100| -1 || 8 |+------+7 rows in set (0.00 sec) 五. REPLACE 官方文档 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125mysql&gt; create table t4(a int primary key auto_increment, b int);Query OK, 0 rows affected (0.15 sec)mysql&gt; insert into t4 values(NULL, 10);Query OK, 1 row affected (0.02 sec)mysql&gt; insert into t4 values(NULL, 11);Query OK, 1 row affected (0.03 sec)mysql&gt; insert into t4 values(NULL, 12);Query OK, 1 row affected (0.03 sec)mysql&gt; select * from t4;+---+------+| a | b |+---+------+| 1 | 10 || 2 | 11 || 3 | 12 |+---+------+3 rows in set (0.00 sec)mysql&gt; insert into t4 values(1, 100); -- 报错，说存在重复的主键记录 "1"ERROR 1062 (23000): Duplicate entry '1' for key 'PRIMARY'mysql&gt; replace into t4 values(1, 100); -- 替换该主键对应的值 Query OK, 2 rows affected (0.03 sec) -- 两行记录受到影响mysql&gt; select * from t4;+---+------+| a | b |+---+------+| 1 | 100 | -- 已经被替换| 2 | 11 || 3 | 12 |+---+------+3 rows in set (0.00 sec)------- replace的原理是：先delete，在insert-----mysql&gt; replace into t4 values(5, 50); -- 没有替换对象时，类似插入效果Query OK, 1 row affected (0.03 sec) -- 只影响1行mysql&gt; select * from t4;+---+------+| a | b |+---+------+| 1 | 100 || 2 | 11 || 3 | 12 || 5 | 50 | -- 插入了1行+---+------+4 rows in set (0.00 sec)---- replace原理更明显的例子 --mysql&gt; create table t6 -&gt; (a int primary key, -&gt; b int auto_increment, -- b是auto_increment的int型数据 -&gt; c int, key(b));Query OK, 0 rows affected (0.15 sec)mysql&gt; insert into t6 values(10, NULL, 100),(20,NULL,200); -- b自增长Query OK, 2 rows affected (0.02 sec)Records: 2 Duplicates: 0 Warnings: 0mysql&gt; select * from t6;+----+---+------+| a | b | c |+----+---+------+| 10 | 1 | 100 | -- b为1| 20 | 2 | 200 | -- b为2+----+---+------+2 rows in set (0.00 sec)mysql&gt; replace into t6 values(10,NULL,150); -- 将a=10的替换掉Query OK, 2 rows affected (0.03 sec)mysql&gt; select * from t6;+----+---+------+| a | b | c |+----+---+------+| 10 | 3 | 150 | -- 替换后b从1变成了3，说明是先删除，再插入| 20 | 2 | 200 |+----+---+------+2 rows in set (0.00 sec)--------- insert on duplicate 效果和 replace类似--mysql&gt; insert into t4 values(1,1); -- 插入报错，存在key为1的记录ERROR 1062 (23000): Duplicate entry '1' for key 'PRIMARY'mysql&gt; insert into t4 values(1,1) on duplicate key update b=1; -- 带上on duplicate参数 -- 非SQL标准，不推荐Query OK, 2 rows affected (0.03 sec)mysql&gt; select * from t4;+---+------+| a | b |+---+------+| 1 | 1 | -- 该行的b列从100被替换成1| 2 | 11 || 3 | 12 || 5 | 50 |+---+------+---- insert ignore--mysql&gt; insert ignore into t4 values(1,1); -- 忽略重复的错误Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; show warnings;+---------+------+---------------------------------------+| Level | Code | Message |+---------+------+---------------------------------------+| Warning | 1062 | Duplicate entry '1' for key 'PRIMARY' |+---------+------+---------------------------------------+1 row in set (0.00 sec) 六. 其他知识点 更新有关系的值 12345678910111213141516171819202122232425mysql&gt; create table t5 (a int, b int);Query OK, 0 rows affected (0.14 sec)mysql&gt; insert into t5 values(1,1);Query OK, 1 row affected (0.03 sec)mysql&gt; select * from t5;+------+------+| a | b |+------+------+| 1 | 1 |+------+------+1 row in set (0.00 sec)mysql&gt; update t5 set a=a+1, b=a where a=1;Query OK, 1 row affected (0.02 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from t5;+------+------+| a | b |+------+------+| 2 | 2 | -- SQL Server和Oracle中得到的值是2, 1+------+------+1 row in set (0.00 se 显示行号(RowNumber) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596---- 方法一--mysql&gt; use employees ;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; set @rn:=0; -- 产生 SESSION(会话)级别的变量Query OK, 0 rows affected (0.00 sec)mysql&gt; select @rn:=@rn+1 as rownumber, emp_no, gender from employees limit 10; -- ：= 是赋值的意思+-----------+--------+--------+| rownumber | emp_no | gender |+-----------+--------+--------+| 11 | 10001 | M || 12 | 10002 | F || 13 | 10003 | M || 14 | 10004 | M || 15 | 10005 | M || 16 | 10006 | F || 17 | 10007 | F || 18 | 10008 | M || 19 | 10009 | F || 20 | 10010 | F |+-----------+--------+--------+10 rows in set (0.00 sec)---- 方法二 （推荐）--mysql&gt; select @rn1:=@rn1+1 as rownumber, emp_no, gender from employees, (select @rn1:=0) as a limit 10;+-----------+--------+--------+| rownumber | emp_no | gender |+-----------+--------+--------+| 1 | 10001 | M || 2 | 10002 | F || 3 | 10003 | M || 4 | 10004 | M || 5 | 10005 | M || 6 | 10006 | F || 7 | 10007 | F || 8 | 10008 | M || 9 | 10009 | F || 10 | 10010 | F |+-----------+--------+--------+10 rows in set (0.00 sec)-- MySQL 自定义变量，根据每一记录进行变化的mysql&gt; select @rn1:=0;+---------+| @rn1:=0 |+---------+| 0 | -- 只有一行记录+---------+1 row in set (0.00 sec)-- 相当于 把 employees 和 (select @rn1:=0)做了笛卡尔积，然后使用@rn1:=@rn + 1，根据每行进行累加---- ":=" 和 "="--mysql&gt; set @a:=1; -- 赋值为1Query OK, 0 rows affected (0.00 sec)mysql&gt; select @a;+------+| @a |+------+| 1 |+------+1 row in set (0.00 sec)mysql&gt; set @a:=10; -- 赋值为10Query OK, 0 rows affected (0.00 sec)mysql&gt; select @a;+------+| @a |+------+| 10 |+------+1 row in set (0.00 sec)mysql&gt; select @a=9; -- 进行比较+------+| @a=9 |+------+| 0 | -- 返回为False+------+1 row in set (0.00 sec)---- 作业：通过子查询或者其他方式，计算出employees的行号--]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记（Day010：Employees/临时表的创建/外键约束）]]></title>
    <url>%2F2018%2F06%2F02%2FMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(Day010)%2F</url>
    <content type="text"><![CDATA[MySQL学习笔记（Day010：Employees/临时表的创建/外键约束）@(MySQL学习) [TOC] 一. Employees数据库安装1. Employees数据库介绍Employees数据库是一个用于学习和测试的数据库，大约160MB，4百万条记录 2. Employees的安装 官方安装文档 2.1. 下载根据官方文档的连接，我们可以找到下载该数据库的两种方式 employees_db-full-1.0.6.tar.bz2 github-test_db 使用git clone 进行仓库拉取 2.2. 解压和拉取12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152[root@MyServer Downloads]&gt; tar jxf employees_db-full-1.0.6.tar.bz2 # 老师讲解时说是解压有问题，但是我这里却可以解压[root@MyServer Downloads]&gt; cd employees_db[root@MyServer employees_db]&gt; lltotal 164492-rw-r--r--. 1 501 games 752 Mar 30 2009 Changelog-rw-r--r--. 1 501 games 6460 Oct 9 2008 employees_partitioned2.sql-rw-r--r--. 1 501 games 7624 Feb 6 2009 employees_partitioned3.sql-rw-r--r--. 1 501 games 5660 Feb 6 2009 employees_partitioned.sql-rw-r--r--. 1 501 games 3861 Nov 28 2008 employees.sql # 主要文件-rw-r--r--. 1 501 games 241 Jul 30 2008 load_departments.dump-rw-r--r--. 1 501 games 13828291 Mar 30 2009 load_dept_emp.dump-rw-r--r--. 1 501 games 1043 Jul 30 2008 load_dept_manager.dump-rw-r--r--. 1 501 games 17422825 Jul 30 2008 load_employees.dump-rw-r--r--. 1 501 games 115848997 Jul 30 2008 load_salaries.dump-rw-r--r--. 1 501 games 21265449 Jul 30 2008 load_titles.dump-rw-r--r--. 1 501 games 3889 Mar 30 2009 objects.sql-rw-r--r--. 1 501 games 2211 Jul 30 2008 README-rw-r--r--. 1 501 games 4455 Mar 30 2009 test_employees_md5.sql-rw-r--r--. 1 501 games 4450 Mar 30 2009 test_employees_sha.sql[root@MyServer github_employees]&gt; git clone https://github.com/datacharmer/test_db.gitInitialized empty Git repository in /root/Downloads/github_employees/test_db/.git/Cloning into 'test_db'...remote: Counting objects: 94, done.remote: Total 94 (delta 0), reused 0 (delta 0), pack-reused 94Unpacking objects: 100% (94/94), done.Checking connectivity... done.[root@MyServer test_db]&gt; lltotal 168340-rw-r--r--. 1 root root 964 Dec 2 21:25 Changelog-rw-r--r--. 1 root root 7948 Dec 2 21:25 employees_partitioned_5.1.sql-rw-r--r--. 1 root root 6276 Dec 2 21:25 employees_partitioned.sql-rw-r--r--. 1 root root 4193 Dec 2 21:25 employees.sql # 主要文件drwxrwxr-x. 2 root root 4096 Dec 2 21:25 images-rw-r--r--. 1 root root 250 Dec 2 21:25 load_departments.dump-rw-r--r--. 1 root root 14159880 Dec 2 21:25 load_dept_emp.dump-rw-r--r--. 1 root root 1090 Dec 2 21:25 load_dept_manager.dump-rw-r--r--. 1 root root 17722832 Dec 2 21:25 load_employees.dump-rw-r--r--. 1 root root 39806034 Dec 2 21:25 load_salaries1.dump-rw-r--r--. 1 root root 39805981 Dec 2 21:25 load_salaries2.dump-rw-r--r--. 1 root root 39080916 Dec 2 21:25 load_salaries3.dump-rw-r--r--. 1 root root 21708736 Dec 2 21:25 load_titles.dump-rw-r--r--. 1 root root 4568 Dec 2 21:25 objects.sql-rw-r--r--. 1 root root 4007 Dec 2 21:25 README.mddrwxrwxr-x. 2 root root 4096 Dec 2 21:25 sakila-rw-r--r--. 1 root root 272 Dec 2 21:25 show_elapsed.sql-rwxr-xr-x. 1 root root 1800 Dec 2 21:25 sql_test.sh-rw-r--r--. 1 root root 4878 Dec 2 21:25 test_employees_md5.sql-rw-r--r--. 1 root root 4882 Dec 2 21:25 test_employees_sha.sql 解压出来的主要文件大小是不一样的，且根据网页上发布和更新的时间上看，github中的时间比较新，所以这里使用github中源作为的安装文件 2.3. 安装1234567891011121314151617181920[root@MyServer test_db]&gt; mysql -uroot -S /tmp/mysql.sock_57 -p &lt; employees.sql Enter password: INFOCREATING DATABASE STRUCTUREINFOstorage engine: InnoDBINFOLOADING departmentsINFOLOADING employeesINFOLOADING dept_empINFOLOADING dept_managerINFOLOADING titlesINFOLOADING salariesdata_load_time_diff00:01:51 2.4. 验证123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106[root@MyServer test_db]&gt; time mysql -uroot -S /tmp/mysql.sock_57 -p -t &lt; test_employees_sha.sql Enter password: +----------------------+| INFO |+----------------------+| TESTING INSTALLATION |+----------------------++--------------+------------------+------------------------------------------+| table_name | expected_records | expected_crc |+--------------+------------------+------------------------------------------+| employees | 300024 | 4d4aa689914d8fd41db7e45c2168e7dcb9697359 || departments | 9 | 4b315afa0e35ca6649df897b958345bcb3d2b764 || dept_manager | 24 | 9687a7d6f93ca8847388a42a6d8d93982a841c6c || dept_emp | 331603 | d95ab9fe07df0865f592574b3b33b9c741d9fd1b || titles | 443308 | d12d5f746b88f07e69b9e36675b6067abb01b60e || salaries | 2844047 | b5a1785c27d75e33a4173aaa22ccf41ebd7d4a9f |+--------------+------------------+------------------------------------------++--------------+------------------+------------------------------------------+| table_name | found_records | found_crc |+--------------+------------------+------------------------------------------+| employees | 300024 | 4d4aa689914d8fd41db7e45c2168e7dcb9697359 || departments | 9 | 4b315afa0e35ca6649df897b958345bcb3d2b764 || dept_manager | 24 | 9687a7d6f93ca8847388a42a6d8d93982a841c6c || dept_emp | 331603 | d95ab9fe07df0865f592574b3b33b9c741d9fd1b || titles | 443308 | d12d5f746b88f07e69b9e36675b6067abb01b60e || salaries | 2844047 | b5a1785c27d75e33a4173aaa22ccf41ebd7d4a9f |+--------------+------------------+------------------------------------------++--------------+---------------+-----------+| table_name | records_match | crc_match |+--------------+---------------+-----------+| employees | OK | ok || departments | OK | ok || dept_manager | OK | ok || dept_emp | OK | ok || titles | OK | ok || salaries | OK | ok |+--------------+---------------+-----------++------------------+| computation_time |+------------------+| 00:00:18 |+------------------++---------+--------+| summary | result |+---------+--------+| CRC | OK || count | OK |+---------+--------+real 0m19.406suser 0m0.005ssys 0m0.004s[root@MyServer test_db]&gt; time mysql -uroot -S /tmp/mysql.sock_57 -p -t &lt; test_employees_md5.sql Enter password: +----------------------+| INFO |+----------------------+| TESTING INSTALLATION |+----------------------++--------------+------------------+----------------------------------+| table_name | expected_records | expected_crc |+--------------+------------------+----------------------------------+| employees | 300024 | 4ec56ab5ba37218d187cf6ab09ce1aa1 || departments | 9 | d1af5e170d2d1591d776d5638d71fc5f || dept_manager | 24 | 8720e2f0853ac9096b689c14664f847e || dept_emp | 331603 | ccf6fe516f990bdaa49713fc478701b7 || titles | 443308 | bfa016c472df68e70a03facafa1bc0a8 || salaries | 2844047 | fd220654e95aea1b169624ffe3fca934 |+--------------+------------------+----------------------------------++--------------+------------------+----------------------------------+| table_name | found_records | found_crc |+--------------+------------------+----------------------------------+| employees | 300024 | 4ec56ab5ba37218d187cf6ab09ce1aa1 || departments | 9 | d1af5e170d2d1591d776d5638d71fc5f || dept_manager | 24 | 8720e2f0853ac9096b689c14664f847e || dept_emp | 331603 | ccf6fe516f990bdaa49713fc478701b7 || titles | 443308 | bfa016c472df68e70a03facafa1bc0a8 || salaries | 2844047 | fd220654e95aea1b169624ffe3fca934 |+--------------+------------------+----------------------------------++--------------+---------------+-----------+| table_name | records_match | crc_match |+--------------+---------------+-----------+| employees | OK | ok || departments | OK | ok || dept_manager | OK | ok || dept_emp | OK | ok || titles | OK | ok || salaries | OK | ok |+--------------+---------------+-----------++------------------+| computation_time |+------------------+| 00:00:16 |+------------------++---------+--------+| summary | result |+---------+--------+| CRC | OK || count | OK |+---------+--------+real 0m18.452suser 0m0.007ssys 0m0.005s 至此，Employees测试数据库就安装完成了 二. 表(TABLE)1. 表的介绍 表是关系数据库的核心 表 = 关系 表是记录的集合 二维表格模型易于人的理解 MySQL默认存储引擎都是基于行(记录)存储 每行记录都是基于列进行组织的 2. 表是数据的集合1select * from table_name limit 1; 集合是无序的，上面的SQL语句的意思是 从表(集合)中随机选出一条数据，结果是不确定的, 不能简单的认为是取出第一条数据。 1select * from table_name order by col_name limit 1; 只有通过order by排序之后取出的数据，才是确定的。 3. 创建表3.1. 临时表 官方文档 表创建的语法 临时表的创建123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187---- mysql 5.7.9--mysql&gt; select version();+-----------+| version() |+-----------+| 5.7.9-log |+-----------+1 row in set (0.00 sec)mysql&gt; use burn_test;Database changedmysql&gt; create temporary table temp_a(a int);Query OK, 0 rows affected (0.01 sec)mysql&gt; show create table temp_a\G*************************** 1. row *************************** Table: temp_aCreate Table: CREATE TEMPORARY TABLE `temp_a` ( `a` int(11) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 -- 使用的是innodb 1 row in set (0.00 sec)---- mysql 5.6.27--mysql&gt; select version();+------------+| version() |+------------+| 5.6.27-log |+------------+1 row in set (0.00 sec)mysql&gt; create temporary table temp_a_56(a int);Query OK, 0 rows affected (0.06 sec)mysql&gt; show create table temp_a_56\G*************************** 1. row *************************** Table: temp_a_56Create Table: CREATE TEMPORARY TABLE `temp_a_56` ( `a` int(11) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 -- 5.6 也是innodb1 row in set (0.00 sec)--------- 终端1 MySQL 5.7.9--mysql&gt; select version();+-----------+| version() |+-----------+| 5.7.9-log |+-----------+1 row in set (0.00 sec)mysql&gt; show processlist\G*************************** 1. row *************************** Id: 10 -- 当前ID 是 10 User: root Host: localhost db: burn_testCommand: Query Time: 0 State: starting Info: show processlist -- 当前终端执行*************************** 2. row *************************** Id: 12 User: root Host: localhost db: NULLCommand: Sleep Time: 328 State: Info: NULL*************************** 3. row *************************** Id: 13 User: root Host: localhost db: burn_testCommand: Sleep Time: 16 State: Info: NULL3 rows in set (0.00 sec)mysql&gt; insert into temp_a values(123);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from temp_a; +------+| a |+------+| 123 |+------+1 row in set (0.00 sec)---- 终端2 MySQL 5.7.9--mysql&gt; select version();+-----------+| version() |+-----------+| 5.7.9-log |+-----------+1 row in set (0.00 sec)mysql&gt; show processlist\G*************************** 1. row *************************** Id: 10 User: root Host: localhost db: burn_testCommand: Sleep Time: 75 State: Info: NULL*************************** 2. row *************************** Id: 12 User: root Host: localhost db: NULLCommand: Sleep Time: 403 State: Info: NULL*************************** 3. row *************************** Id: 13 -- 当前 ID 是 13 User: root Host: localhost db: burn_testCommand: Query Time: 0 State: starting Info: show processlist -- 当前终端执行3 rows in set (0.00 sec)mysql&gt; use burn_test;Database changedmysql&gt; show tables;Empty set (0.00 sec) -- 从其他终端登录的用户(session)无法看到temp_a这个临时表-------- 临时表 和 普通表 同名问题--mysql&gt; create table test_1 (a int); -- 创建一张普通的表叫做 test_1Query OK, 0 rows affected (0.16 sec)mysql&gt; insert into test_1 values(23);Query OK, 1 row affected (0.03 sec)mysql&gt; insert into test_1 values(24);Query OK, 1 row affected (0.03 sec)mysql&gt; select * from test_1;+------+| a |+------+| 23 | -- 可以看到插入的数据| 24 |+------+2 rows in set (0.00 sec)mysql&gt; create temporary table test_1 (a int); -- 创建一种和test_1 同名的临时表Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into test_1 values(1000); -- 插入一个 不一样的值Query OK, 1 row affected (0.00 sec)mysql&gt; select * from test_1;+------+| a |+------+| 1000 | -- 只能搜索到 临时表中的数据+------+1 row in set (0.00 sec)mysql&gt; create temporary table if not exists table_name (a int); -- 使用if not exists进行判断 1：临时表是SESSION级别的, 当前用户logout或者其他用户登录上来，是无法看到这张表的2：当临时表和普通表同名时，当前用户只能看到同名的临时表3：创建表时带上if not exists进行表的存在性检查；同时建议在临时表的表名前面加上统一的prefix 临时表的作用 临时表主要的作用是给当前登录的用户存储临时数据或者临时结果的。 不要和SQL优化器在排序过程中内部帮你创建的临时表相混淆。 临时表的存储引擎 12345678910111213141516171819202122232425262728293031323334mysql&gt; select version();+-----------+| version() |+-----------+| 5.7.9-log |+-----------+1 row in set (0.00 sec)mysql&gt; show variables like "default%tmp%";+----------------------------+--------+| Variable_name | Value |+----------------------------+--------+| default_tmp_storage_engine | InnoDB | -- 5.7.9 的临时表默认存储引擎就是 InnoDB+----------------------------+--------+1 row in set (0.00 sec)mysql&gt; select version();+------------+| version() |+------------+| 5.6.27-log |+------------+1 row in set (0.00 sec)mysql&gt; show variables like "default%tmp%";+----------------------------+--------+| Variable_name | Value |+----------------------------+--------+| default_tmp_storage_engine | InnoDB | -- 5.7.26 的临时表默认存储引擎也是 InnoDB+----------------------------+--------+1 row in set (0.00 sec)-- 5.6 之前用的是MyISAM 临时表存储位置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546## MySQL 5.7#mysql&gt; system ls -l /tmp # 使用system 可以解析执行linux shell命令total 20drwxr-xr-x. 4 mysql mysql 4096 Dec 2 10:06 mysql_datasrwxrwxrwx. 1 mysql mysql 0 Dec 2 21:20 mysql.sock_56srwxrwxrwx. 1 mysql mysql 0 Dec 2 20:51 mysql.sock_57-rw-------. 1 mysql mysql 5 Dec 2 20:51 mysql.sock_57.lock-rw-r-----. 1 mysql mysql 8554 Dec 2 22:04 #sqlf18_a_0.frm -- temp_1 的表结构mysql&gt; system ls -l /data/mysql_data/5.7/ | grep ib-rw-r-----. 1 mysql mysql 879 Dec 2 20:47 ib_buffer_pool-rw-r-----. 1 mysql mysql 12582912 Dec 2 22:21 ibdata1-rw-r-----. 1 mysql mysql 134217728 Dec 2 22:20 ib_logfile0-rw-r-----. 1 mysql mysql 134217728 Dec 2 21:33 ib_logfile1-rw-r-----. 1 mysql mysql 12582912 Dec 2 22:33 ibtmp1 -- 这个是我们的表结构对应的数据mysql&gt; show variables like "innodb_temp%";+----------------------------+-----------------------+| Variable_name | Value |+----------------------------+-----------------------+| innodb_temp_data_file_path | ibtmp1:12M:autoextend |+----------------------------+-----------------------+1 row in set (0.00 sec)#-----## MySQL 5.6#mysql&gt; system ls -l /tmptotal 68drwxr-xr-x. 4 mysql mysql 4096 Dec 2 10:06 mysql_datasrwxrwxrwx. 1 mysql mysql 0 Dec 2 21:20 mysql.sock_56srwxrwxrwx. 1 mysql mysql 0 Dec 2 20:51 mysql.sock_57-rw-------. 1 mysql mysql 5 Dec 2 20:51 mysql.sock_57.lock-rw-rw----. 1 mysql mysql 8554 Dec 2 22:38 #sql13f3_7_0.frm -- 表结构-rw-rw----. 1 mysql mysql 49152 Dec 2 22:38 #sql13f3_7_0.ibd -- 表数据# 5.6.27 中没有 innodb_temp_data_file_path 变量mysql&gt; show variables like "innodb_temp%";Empty set (0.00 sec)mysql&gt; show variables like "%innodb%temp%";Empty set (0.00 sec) MySQL5.7.9 把临时表结构放在tmpdir，而数据表数据放在datadirMySQL5.6.27 把临时表结构和表数据都放在tmpdir 4. 查看表结构123456789101112131415161718192021222324252627282930313233343536373839mysql&gt; show create table test_1\G -- 表结构*************************** 1. row *************************** Table: test_1Create Table: CREATE TABLE `test_1` ( `a` int(11) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb41 row in set (0.00 sec)mysql&gt; desc test_1\G -- 表的描述,描述二维表信息*************************** 1. row *************************** Field: a Type: int(11) Null: YES Key: Default: NULL Extra: 1 row in set (0.00 sec)mysql&gt; show table status like "test_1"\G -- 看表结构的元数据信息*************************** 1. row *************************** Name: test_1 Engine: InnoDB Version: 10 Row_format: Dynamic Rows: 2 Avg_row_length: 4096 Data_length: 8192Max_data_length: 0 Index_length: 0 Data_free: 0 Auto_increment: NULL Create_time: 2015-12-02 22:20:19 Update_time: 2015-12-02 22:20:44 Check_time: NULL Collation: utf8mb4_general_ci Checksum: NULL Create_options: Comment: 1 row in set (0.00 sec) 5. ALTER TABLE ALTER TABLE语法官方文档12345678910111213141516171819202122232425mysql&gt; alter table test_1 add column b char(10); -- 添加列 bQuery OK, 0 rows affected (0.25 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; select * from test_1;+------+------+| a | b |+------+------+| 23 | NULL || 24 | NULL |+------+------+2 rows in set (0.00 sec)mysql&gt; alter table test_1 drop column b; -- 删除列 bQuery OK, 0 rows affected (0.27 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; select * from test_1;+------+| a |+------+| 23 || 24 |+------+2 rows in set (0.00 sec) 注意，当表记录很大的时候，alter table会很耗时，影响性能 ONLINE DDL5.6以后对在线DDL操作进行了优化，以提高性能。官方文档 三. 外键约束1. 外键的介绍 官方文档12345678910111213141516171819202122232425262728293031323334---- 摘自 MySQL官方文档--CREATE TABLE product ( -- 商品表 category INT NOT NULL, -- 商品种类 id INT NOT NULL, -- 商品id price DECIMAL, PRIMARY KEY(category, id) -- 主键是 (category, id)) ENGINE=INNODB;CREATE TABLE customer ( -- 客户表 id INT NOT NULL, -- 客户id PRIMARY KEY (id) -- 主键是 id) ENGINE=INNODB;CREATE TABLE product_order ( -- 订单表 no INT NOT NULL AUTO_INCREMENT, -- number，自增长 product_category INT NOT NULL, -- 商品种类 product_id INT NOT NULL, -- 商品id customer_id INT NOT NULL, -- 客户id PRIMARY KEY(no), -- 主键是 no INDEX (product_category, product_id), -- 对 (product_category, product_id) 做索引 INDEX (customer_id), -- 对 customer_id 做索引 FOREIGN KEY (product_category, product_id) -- 两个外键约束 REFERENCES product(category, id) -- 字段 product_category 引用自 product表的category -- 字段 product_id 引用自 product表的id ON UPDATE CASCADE ON DELETE RESTRICT, -- 级联跟新 和 严格模式删除 FOREIGN KEY (customer_id) REFERENCES customer(id)) ENGINE=INNODB; 2. 外键操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100---- 表结构 摘自 MySQL 官方文档--mysql&gt; create table parent ( -&gt; id int not null, -&gt; primary key (id) -&gt; ) engine=innodb;Query OK, 0 rows affected (0.14 sec)mysql&gt; create table child ( -&gt; id int, -&gt; parent_id INT, -&gt; index par_ind (parent_id), -&gt; foreign key (parent_id) -&gt; references parent(id) -&gt; on delete cascade on update cascade -- 比官网例子增加 update cascade -&gt; ) engine=innodb;Query ok, 0 rows affected (0.15 sec)mysql&gt; insert into child values(1,1); -- 我们插入一条数据，id=1，parent_id=1ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`burn_test`.`child`, CONSTRAINT `child_ibfk_1` FOREIGN KEY (`parent_id`) REFERENCES `parent` (`id`) ON DELETE CASCADE) -- 直接报错了，因为此时parent表中没有任何记录mysql&gt; insert into parent values(1); -- 现在parent中插入记录Query OK, 1 row affected (0.03 sec)mysql&gt; insert into child values(1,1); -- 然后在child中插入记录，且parent_id是在parent中存在的Query OK, 1 row affected (0.02 sec)mysql&gt; insert into child values(1,2); -- 插入parent_id=2的记录，报错。因为此时parent_id=2的记录不存在ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`burn_test`.`child`, CONSTRAINT `child_ibfk_1` FOREIGN KEY (`parent_id`) REFERENCES `parent` (`id`) ON DELETE CASCADE)mysql&gt; select * from child; +------+-----------+| id | parent_id |+------+-----------+| 1 | 1 | -- parent_id = 1+------+-----------+1 row in set (0.00 sec)mysql&gt; select * from parent;+----+| id |+----+| 1 | -- 根据表结构的定义（Foreign_key），这个值就是 child表中的id+----+1 row in set (0.00 sec)mysql&gt; update parent set id=100 where id=1; Query OK, 1 row affected (0.04 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from parent;+-----+| id |+-----+| 100 | -- 已经设置成了100+-----+1 row in set (0.00 sec)mysql&gt; select * from child;+------+-----------+| id | parent_id |+------+-----------+| 1 | 100 | -- 自动变化，这是on update cascade的作用，联级更新，parent更新，child也跟着更新+------+-----------+1 row in set (0.00 sec)mysql&gt; delete from parent where id=100; -- 删除这条记录Query OK, 1 row affected (0.03 sec)mysql&gt; select * from parent; -- id=100的记录已经被删除了Empty set (0.00 sec)mysql&gt; select * from child; -- id=1，parent_id=100的记录跟着被删除了。on delete cascade的作用Empty set (0.00 sec)mysql&gt; alter table child drop foreign key child_ibfk_1; -- 删除 之前的外键Query OK, 0 rows affected (0.07 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; alter table child add foreign key(parent_id) -&gt; references parent(id) on update cascade on delete restrict; -- 使用严格模式Query OK, 0 rows affected (0.27 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; insert into parent values(50);Query OK, 1 row affected (0.03 sec)mysql&gt; insert into child values(3,50); Query OK, 1 row affected (0.03 sec)mysql&gt; insert into child values(3,51); -- 和之前一样会提示错误ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`burn_test`.`child`, CONSTRAINT `child_ibfk_1` FOREIGN KEY (`parent_id`) REFERENCES `parent` (`id`) ON UPDATE CASCADE)mysql&gt; delete from parent where id=50; -- 删除失败了，因为是restrict模式ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`burn_test`.`child`, CONSTRAINT `child_ibfk_1` FOREIGN KEY (`parent_id`) REFERENCES `parent` (`id`) ON UPDATE CASCADE)-- 注意，delete 后面说明都不写表示 no action == restrict 外键约束，可以让数据进行一致性更新，但是会有一定的性能损耗，线上业务使用不多。通常上述级联更新和删除都是由应用层业务逻辑进行判断并实现。]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记（Day009：JSON）]]></title>
    <url>%2F2018%2F06%2F01%2FMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(Day009%EF%BC%9AJSON)%2F</url>
    <content type="text"><![CDATA[MySQL学习笔记（Day009：JSON）@(MySQL学习) [TOC] 一. MySQL JSON类型1. JSON介绍 JSON（JavaScript Object Notation）是一种轻量级的数据交换语言，并且是独立于语言的文本格式。 一些NoSQL数据库选择JSON作为其数据存储格式，比如：MongoDB、CouchDB等。 MySQL5.7.x开始支持JSON数据类型。 官方文档(JSON类型) 2. JSON格式示例12345678910111213141516171819202122232425262728---- 摘自 维基百科--&#123; "firstName": "John", -- Key : Value 格式 "lastName": "Smith", "sex": "male", "age": 25, "address": -- Key : Value ; 其中 Value 也是一个 Key-Value 的结构 &#123; "streetAddress": "21 2nd Street", "city": "New York", "state": "NY", "postalCode": "10021" &#125;, "phoneNumber": [ &#123; "type": "home", "number": "212 555-1234" &#125;, &#123; "type": "fax", "number": "646 555-4567" &#125; ] &#125; 3. JSON VS BLOB JSON JSON数据可以做有效性检查; JSON使得查询性能提升; JSON支持部分属性索引，通过虚拟列的功能可以对JSON中的部分数据进行索引; BLOB BLOB类型无法在数据库层做约束性检查; BLOB进行查询，需要遍历所有字符串; BLOB做只能做指定长度的索引; 5.7之前，只能把JSON当作BLOB进行存储。数据库层面无法对JSON数据做一些操作，只能由应用程序处理。 4.结构化和非结构化 结构化 二维表结构（行和列） 使用SQL语句进行操作 非结构化 使用Key-Value格式定义数据，无结构定义 Value可以嵌套Key-Value格式的数据 使用JSON进行实现 123456789---- SQL创建User表--create table user ( id bigint not null auto_increment, user_name varchar(10), age int, primary key(id)); 12345678910## JSON定义的User表#db.user.insert(&#123; user_name:"tom", age:30&#125;)db.createCollection("user") 5. JSON操作示例5.1 JSON入门1234567891011121314151617181920212223242526272829303132333435363738394041424344---- 创建带json字段的表--mysql&gt; create table user ( -&gt; uid int auto_increment, -&gt; data json, -&gt; primary key(uid) -&gt; );Query OK, 0 rows affected (0.11 sec)---- 插入json数据--mysql&gt; insert into user values ( -&gt; null, -- 自增长数据，可以插入null -&gt; '&#123; '&gt; "name":"tom", '&gt; "age":18, '&gt; "address":"SZ" '&gt; &#125;' -&gt; );Query OK, 1 row affected (0.03 sec)mysql&gt; insert into user values ( -&gt; null, -&gt; '&#123; '&gt; "name":"jim", '&gt; "age":28, '&gt; "mail":"jim@163.com" '&gt; &#125;' -&gt; );Query OK, 1 row affected (0.02 sec)mysql&gt; insert into user values ( null, "can you insert it?"); -- 无法插入，因为是JSON类型ERROR 3140 (22032): Invalid JSON text: "Invalid value." at position 0 in value (or column) can you insert it?. -- 这短话有单引号，但是渲染有问题，所以这里去掉了mysql&gt; select * from user;+-----+---------------------------------------------------+| uid | data |+-----+---------------------------------------------------+| 1 | &#123;"age": 18, "name": "tom", "address": "SZ"&#125; | -- 这个json中有address字段| 2 | &#123;"age": 28, "mail": "jim@163.com", "name": "jim"&#125; | -- 这个json中有mail字段+-----+---------------------------------------------------+2 rows in set (0.00 sec) 5.2 JSON常用函数介绍123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168---- 使用json_extract提取数据-- 原型 : JSON_EXTRACT(json_doc, path[, path] ...) --mysql&gt; select json_extract('[10, 20, [30, 40]]', '$[1]'); +--------------------------------------------+| json_extract('[10, 20, [30, 40]]', '$[1]') |+--------------------------------------------+| 20 | -- 从list中抽取 下标 为1的元素（下标从0开始）+--------------------------------------------+1 row in set (0.00 sec)mysql&gt; select -&gt; json_extract(data, '$.name'), -- 提起name字段的数据 -&gt; json_extract(data, '$.address') -- 提取address字段的数据 -&gt; from user;+------------------------------+---------------------------------+| json_extract(data, '$.name') | json_extract(data, '$.address') |+------------------------------+---------------------------------+| "tom" | "SZ" || "jim" | NULL | -- jim 没有address字段，填充了NULL+------------------------------+---------------------------------+2 rows in set (0.00 sec)---- json_object 将list(K-V对)封装成json格式-- 原型 : JSON_OBJECT([key, val[, key, val] ...])--mysql&gt; select json_object("name", "jery", "email", "jery@163.com", "age",33);+----------------------------------------------------------------+| json_object("name", "jery", "email", "jery@163.com", "age",33) |+----------------------------------------------------------------+| &#123;"age": 33, "name": "jery", "email": "jery@163.com"&#125; | -- 封装成了K-V对+----------------------------------------------------------------+1 row in set (0.00 sec)mysql&gt; insert into user values ( -&gt; null, -&gt; json_object("name", "jery", "email", "jery@163.com", "age",33) -- 进行封装 -&gt; );Query OK, 1 row affected (0.03 sec)mysql&gt; select * from user;+-----+------------------------------------------------------+| uid | data |+-----+------------------------------------------------------+| 1 | &#123;"age": 18, "name": "tom", "address": "SZ"&#125; || 2 | &#123;"age": 28, "mail": "jim@163.com", "name": "jim"&#125; || 4 | &#123;"age": 33, "name": "jery", "email": "jery@163.com"&#125; |+-----+------------------------------------------------------+3 rows in set (0.00 sec)---- json_insert 插入数据-- 原型 : JSON_INSERT(json_doc, path, val[, path, val] ...)--mysql&gt; set @j = '&#123; "a": 1, "b": [2, 3]&#125;';Query OK, 0 rows affected (0.00 sec)mysql&gt; select json_insert(@j, '$.a', 10, '$.c', '[true, false]'); +----------------------------------------------------+| json_insert(@j, '$.a', 10, '$.c', '[true, false]') |+----------------------------------------------------+| &#123;"a": 1, "b": [2, 3], "c": "[true, false]"&#125; | -- a还是=1，存在的被忽略，不受影响+----------------------------------------------------+ -- c之前不存在，则插入1 row in set (0.00 sec)mysql&gt; update user set data = json_insert(data, "$.address_2", "BJ") where uid = 1; -- 插入 addres_2Query OK, 1 row affected (0.03 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from user;+-----+----------------------------------------------------------------+| uid | data |+-----+----------------------------------------------------------------+| 1 | &#123;"age": 18, "name": "tom", "address": "SZ", "address_2": "BJ"&#125; | -- 增加了addres_2 : "BJ"| 2 | &#123;"age": 28, "mail": "jim@163.com", "name": "jim"&#125; || 4 | &#123;"age": 33, "name": "jery", "email": "jery@163.com"&#125; |+-----+----------------------------------------------------------------+3 rows in set (0.00 sec)---- json_merge 合并数据并返回。注意：原数据不受影响-- 原型 : JSON_MERGE(json_doc, json_doc[, json_doc] ...)--mysql&gt; select json_merge('&#123;"name": "x"&#125;', '&#123;"id": 47&#125;'); -- 原来有两个JSON +-------------------------------------------+| json_merge('&#123;"name": "x"&#125;', '&#123;"id": 47&#125;') |+-------------------------------------------+| &#123;"id": 47, "name": "x"&#125; | -- 合并多个JSON+-------------------------------------------+1 row in set (0.00 sec)mysql&gt; select -&gt; json_merge( -&gt; json_extract(data, '$.address'), -- json 1 -&gt; json_extract(data, '$.address_2')) -- jons 2 -&gt; from user where uid = 1;+---------------------------------------------------------------------------------+| json_merge( json_extract(data, '$.address'), json_extract(data, '$.address_2')) |+---------------------------------------------------------------------------------+| ["SZ", "BJ"] | -- 合并成一个json+---------------------------------------------------------------------------------+1 row in set (0.00 sec)---- json_array_append 追加数据-- 原型 : JSON_ARRAY_APPEND(json_doc, path, val[, path, val] ...) -- json_append 在5.7.9 中重命名为 json_array_append--mysql&gt; set @j = '["a", ["b", "c"], "d"]'; -- 下标为1的元素中只有["b", "c"]Query OK, 0 rows affected (0.00 sec)mysql&gt; select json_array_append(@j, '$[1]', 1); +----------------------------------+| json_array_append(@j, '$[1]', 1) |+----------------------------------+| ["a", ["b", "c", 1], "d"] | -- 现在插入了 数字 1+----------------------------------+1 row in set (0.00 sec)mysql&gt; update user set data = json_array_append( -&gt; data, -&gt; '$.address', -&gt; json_extract(data, '$.address_2')) -&gt; where uid = 1;Query OK, 1 row affected (0.02 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from user;+-----+------------------------------------------------------------------------+| uid | data |+-----+------------------------------------------------------------------------+| 1 | &#123;"age": 18, "name": "tom", "address": ["SZ", "BJ"], "address_2": "BJ"&#125; | --address_2追加到address| 2 | &#123;"age": 28, "mail": "jim@163.com", "name": "jim"&#125; || 4 | &#123;"age": 33, "name": "jery", "email": "jery@163.com"&#125; |+-----+------------------------------------------------------------------------+3 rows in set (0.00 sec)---- json_remove 从json记录中删除数据-- 原型 : JSON_REMOVE(json_doc, path[, path] ...)--mysql&gt; set @j = '["a", ["b", "c"], "d"]'; Query OK, 0 rows affected (0.00 sec)mysql&gt; select json_remove(@j, '$[1]');+-------------------------+| json_remove(@j, '$[1]') |+-------------------------+| ["a", "d"] | -- 删除了下标为1的元素["b", "c"]+-------------------------+1 row in set (0.00 sec)mysql&gt; update user set data = json_remove(data, "$.address_2") where uid = 1;Query OK, 1 row affected (0.03 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from user;+-----+------------------------------------------------------+| uid | data |+-----+------------------------------------------------------+| 1 | &#123;"age": 18, "name": "tom", "address": ["SZ", "BJ"]&#125; | -- address_2 的字段删除了| 2 | &#123;"age": 28, "mail": "jim@163.com", "name": "jim"&#125; || 4 | &#123;"age": 33, "name": "jery", "email": "jery@163.com"&#125; |+-----+------------------------------------------------------+3 rows in set (0.00 sec) 官方文档(JSON函数) 5.3 JSON创建索引JSON类型数据本身无法直接创建索引，需要将需要索引的JSON数据重新生成虚拟列(Virtual Columns)之后，对该列进行索引 官方文档–JSON创建索引 新建表时创建JSON索引 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131mysql&gt; create table test_inex_1( -&gt; data json, -&gt; gen_col varchar(10) generated always as (json_extract(data, '$.name')), -- 抽取data中的name， 生成新的一列，名字为gen_col -&gt; index idx (gen_col) -- 将gen_col 作为索引 -&gt; );Query OK, 0 rows affected (0.13 sec)mysql&gt; show create table test_index_1；-- -----省略表格线-----| test_index_1 | CREATE TABLE `test_index_1` ( `data` json DEFAULT NULL, `gen_col` varchar(10) GENERATED ALWAYS AS (json_extract(data, '$.name')) VIRTUAL, KEY `idx` (`gen_col`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 |-- -----省略表格线-----1 row in set (0.00 sec)mysql&gt; insert into test_index_1(data) values ('&#123;"name":"tom", "age":18, "address":"SH"&#125;');Query OK, 1 row affected (0.04 sec)mysql&gt; insert into test_index_1(data) values ('&#123;"name":"jim", "age":28, "address":"SZ"&#125;'); Query OK, 1 row affected (0.03 sec)mysql&gt; select * from test_index_1;+---------------------------------------------+---------+| data | gen_col |+---------------------------------------------+---------+| &#123;"age": 18, "name": "tom", "address": "SH"&#125; | "tom" || &#123;"age": 28, "name": "jim", "address": "SZ"&#125; | "jim" |+---------------------------------------------+---------+2 rows in set (0.00 sec)mysql&gt; select json_extract(data,"$.name") as username from test_index_1 where gen_col="tom"; -- 如果这样做，为空，原因如下Empty set (0.00 sec)mysql&gt; select hex('"');+----------+| hex('"') |+----------+| 22 | -- 双引号的 16进制+----------+1 row in set (0.00 sec)mysql&gt; select hex(gen_col) from test_index_1;+--------------+| hex(gen_col) |+--------------+| 226A696D22 | -- 双引号本身也作为了存储内容| 22746F6D22 |+--------------+2 rows in set (0.00 sec)mysql&gt; select json_extract(data,"$.name") as username from test_index_1 where gen_col='"tom"'; -- 使用'"tome"',用单引号括起来+----------+| username |+----------+| "tom" | -- 找到了对应的数据+----------+1 row in set (0.00 sec)mysql&gt; explain select json_extract(data,"$.name") as username from test_index_1 where gen_col='"tom"'\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: test_index_1 partitions: NULL type: ref possible_keys: idx -- 使用了 key idx key: idx key_len: 43 ref: const rows: 1 filtered: 100.00 Extra: NULL1 row in set, 1 warning (0.00 sec)------ 建立表的时候去掉双引用---mysql&gt; create table test_index_2 ( -&gt; data json, -&gt; gen_col varchar(10) generated always as ( -&gt; json_unquote( -- 使用json_unquote函数进行去掉双引号 -&gt; json_extract(data, "$.name") -&gt; )), -&gt; key idx(gen_col) -&gt; );Query OK, 0 rows affected (0.13 sec)mysql&gt; show create table test_index_2;-- -----省略表格线-----| test_index_2 | CREATE TABLE `test_index_2` ( `data` json DEFAULT NULL, `gen_col` varchar(10) GENERATED ALWAYS AS (json_unquote( json_extract(data, "$.name") )) VIRTUAL, KEY `idx` (`gen_col`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 |-- -----省略表格线-----1 row in set (0.00 sec)mysql&gt; insert into test_index_2(data) values ('&#123;"name":"tom", "age":18, "address":"SH"&#125;');Query OK, 1 row affected (0.03 sec)mysql&gt; insert into test_index_2(data) values ('&#123;"name":"jim", "age":28, "address":"SZ"&#125;');Query OK, 1 row affected (0.02 sec)mysql&gt; select json_extract(data,"$.name") as username from test_index_2 where gen_col="tom"; -- 未加单引号+----------+| username |+----------+| "tom" | -- 可以找到数据+----------+1 row in set (0.00 sec)mysql&gt; explain select json_extract(data,"$.name") as username from test_index_2 where gen_col="tom"\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: test_index_2 partitions: NULL type: refpossible_keys: idx -- 使用了 key idx key: idx key_len: 43 ref: const rows: 1 filtered: 100.00 Extra: NULL1 row in set, 1 warning (0.00 sec) 修改已存在的表创建JSON索引 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879---- 使用之前的user表操作--mysql&gt; show create table user;-- -----省略表格线-----| user | CREATE TABLE `user` ( `uid` int(11) NOT NULL AUTO_INCREMENT, `data` json DEFAULT NULL, PRIMARY KEY (`uid`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 |-- -----省略表格线-----1 row in set (0.00 sec)mysql&gt; select * from user;+-----+------------------------------------------------------+| uid | data |+-----+------------------------------------------------------+| 1 | &#123;"age": 18, "name": "tom", "address": ["SZ", "BJ"]&#125; || 2 | &#123;"age": 28, "mail": "jim@163.com", "name": "jim"&#125; || 4 | &#123;"age": 33, "name": "jery", "email": "jery@163.com"&#125; |+-----+------------------------------------------------------+mysql&gt; alter table user -&gt; add user_name varchar(32) -&gt; generated always as (json_extract(data,"$.name")) virtual;Query OK, 0 rows affected (0.05 sec)Records: 0 Duplicates: 0 Warnings: 0-- virtual 关键字是不将该列的字段值存储，对应的是storedmysql&gt; select user_name from user; +-----------+| user_name |+-----------+| "tom" || "jim" || "jery" |+-----------+3 rows in set (0.00 sec)mysql&gt; alter table user add index idx(user_name); Query OK, 0 rows affected (0.13 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; select * from user where user_name='"tom"'; -- 加单引号+-----+-----------------------------------------------------+-----------+| uid | data | user_name |+-----+-----------------------------------------------------+-----------+| 1 | &#123;"age": 18, "name": "tom", "address": ["SZ", "BJ"]&#125; | "tom" |+-----+-----------------------------------------------------+-----------+1 row in set (0.00 sec)mysql&gt; explain select * from user where user_name='"tom"'\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: user partitions: NULL type: refpossible_keys: idx -- 使用了 key idx key: idx key_len: 131 ref: const rows: 1 filtered: 100.00 Extra: NULL1 row in set, 1 warning (0.00 sec)mysql&gt; show create table user;-- -----省略表格线-----| user | CREATE TABLE `user` ( `uid` int(11) NOT NULL AUTO_INCREMENT, `data` json DEFAULT NULL, `user_name` varchar(32) GENERATED ALWAYS AS (json_extract(data,"$.name")) VIRTUAL, `user_name2` varchar(32) GENERATED ALWAYS AS (json_extract(data,"$.name")) VIRTUAL, PRIMARY KEY (`uid`), KEY `idx` (`user_name`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 |-- -----省略表格线-----1 row in set (0.00 sec) 二. 附录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960---- 老师演示JSON的SQL--drop table if exists User;CREATE TABLE User ( uid BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, name VARCHAR(32) NOT NULL, email VARCHAR(256) NOT NULL, address VARCHAR(512) NOT NULL, UNIQUE KEY (name), UNIQUE KEY (email));INSERT INTO User VALUES (NULL,'David','david@gmail','Shanghai ...');INSERT INTO User VALUES (NULL,'Amy','amy@gmail','Beijing ...');INSERT INTO User VALUES (NULL,'Tom','tom@gmail','Guangzhou ...');SELECT * FROM User;ALTER TABLE User ADD COLUMN address2 VARCHAR(512) NOT NULL;ALTER TABLE User ADD COLUMN passport VARCHAR(64) NOT NULL;DROP TABLE IF EXISTS UserJson;CREATE TABLE UserJson( uid BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, data JSON);truncate table UserJson;insert into UserJson SELECT uid,JSON_OBJECT('name',name,'email',email,'address',address) AS dataFROM User; SELECT * FROM UserJson; SELECT uid,JSON_EXTRACT(data,'$.address2') from UserJson; UPDATE UserJsonset data = json_insert(data,"$.address2","HangZhou ...")where uid = 1;SELECT JSON_EXTRACT(data,'$.address[1]') from UserJson;select json_merge(JSON_EXTRACT(data,'$.address') ,JSON_EXTRACT(data,'$.address2')) from UserJson;begin;UPDATE UserJsonset data = json_array_append(data,"$.address",JSON_EXTRACT(data,'$.address2'))where JSON_EXTRACT(data,'$.address2') IS NOT NULL AND uid &gt;0;select JSON_EXTRACT(data,'$.address') from UserJson;UPDATE UserJsonset data = JSON_REMOVE(data,'$.address2')where uid&gt;0;commit;]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记（Day008：数据类型）]]></title>
    <url>%2F2018%2F05%2F31%2FMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(Day008)%2F</url>
    <content type="text"><![CDATA[MySQL学习笔记（Day008：数据类型）@(MySQL学习) [TOC] 一. INT类型1. INT类型的分类 TINYINT 存储空间 ： 1 字节 取值范围 有符号(signed) ： [-128, 127] 无符号(unsigned) ：[0, 255] SMALLINT 存储空间 ： 2 字节 取值范围 有符号(signed) ： [-32768, 32767] 无符号(unsigned) ：[0, 65535] MEDIUMINT 存储空间 ： 3 字节 取值范围 有符号(signed) ： [-8388608, 8388607] 无符号(unsigned) ：[0, 16777215] INT 存储空间 ： 4 字节 取值范围 有符号(signed) ： [-2147483648, 2147483647] 无符号(unsigned) ：[0, 4294967295] BIGINT 存储空间 ： 8 字节 取值范围 有符号(signed) ： [-9223372036854775808, 9223372036854775807] 无符号(unsigned) ：[0, 18446744073709551615] 2. INT类型的使用 自增长ID 推荐使用BIGINT，而不是INT； unsigned or signed 根据实际情况使用，一般情况下推荐默认的sigend unsigned 的注意事项 123456789101112131415161718192021222324252627mysql&gt; create table test_unsigned(a int unsigned, b int unsigned);Query OK, 0 rows affected (0.14 sec)mysql&gt; insert into test_unsigned values(1, 2);Query OK, 1 row affected (0.03 sec)mysql&gt; select a - b from test_unsigned;ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in '(`burn_test`.`test_unsigned`.`a` - `burn_test`.`test_unsigned`.`b`)'mysql&gt; select b - a from test_unsigned; +-------+| b - a |+-------+| 1 |+-------+1 row in set (0.00 sec)mysql&gt; set sql_mode = 'no_unsigned_subtraction'; -- 这样就可以得到负数Query OK, 0 rows affected (0.00 sec)mysql&gt; select a - b from test_unsigned;+-------+| a - b |+-------+| -1 |+-------+1 row in set (0.00 sec) 一般情况下使用int时，推荐有符号数(signed)， 使用无符号数只是比原来多一倍的取值，数量级上没有改变。 如果需要取值范围很大，直接选择用BIGINT 3. INT(N)12345678910mysql&gt; show create table test_unsigned;+---------------+-------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+---------------+-------------------------------------------------------------------------------------------------------------------------------------------------+| test_unsigned | CREATE TABLE `test_unsigned` ( `a` int(10) unsigned DEFAULT NULL, `b` int(10) unsigned DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 |+---------------+-------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec) int(N) 和 zerofill int(N)中的N是显示宽度，不表示存储的数字的长度的上限。 zerofill表示当存储的数字长度 &lt; N时，用数字0填充左边，直至补满长度N 当存储数字的长度超过N时，按照实际存储的数字显示 12345678910111213141516171819202122232425262728293031323334mysql&gt; create table test_int_n(a int(3) zerofill); -- 显示宽度N=3Query OK, 0 rows affected (0.11 sec)mysql&gt; insert into test_int_n values(1);Query OK, 1 row affected (0.04 sec)mysql&gt; select * from test_int_n;+------+| a |+------+| 001 | -- 不满 N=3时，左边用0填充+------+1 row in set (0.00 sec)mysql&gt; insert into test_int_n values(1111);Query OK, 1 row affected (0.03 sec)mysql&gt; select * from test_int_n;+------+| a |+------+| 001 || 1111 | -- 超过N=3的长度时，是什么数字，显示什么数字+------+2 rows in set (0.00 sec)mysql&gt; select a, HEX(a) from test_int_n\G*************************** 1. row *************************** a: 001HEX(a): 1 -- 实际存储的还是1*************************** 2. row *************************** a: 1111HEX(a): 457 -- 1111对应的16进制就是4572 rows in set (0.00 sec) int(N)中的N和zerofill配合才有意义，且仅仅是显示的时候才有意义，和实际存储没有关系，不会去截取数字的长度。 4. AUTO_INCREMENT 自增 每张表一个 必须是索引的一部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131mysql&gt; create table test_auto_increment(a int auto_increment);ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key-- 没有指定为key，报错了mysql&gt; create table test_auto_increment(a int auto_increment primary key); -- 指定为key后有效Query OK, 0 rows affected (0.11 sec)mysql&gt; insert into test_auto_increment values(NULL); -- 插入NULL值Query OK, 1 row affected (0.03 sec)mysql&gt; select * from test_auto_increment;+---+| a |+---+| 1 | -- 插入NULL值，便可以让其自增，且默认从1开始+---+1 row in set (0.00 sec)mysql&gt; insert into test_auto_increment values(0); -- 插入 0Query OK, 1 row affected (0.03 sec)mysql&gt; select * from test_auto_increment;+---+| a |+---+| 1 || 2 | -- 插入 0 ，自增长为2+---+2 rows in set (0.00 sec)mysql&gt; insert into test_auto_increment values(-1); -- 插入 -1Query OK, 1 row affected (0.02 sec)mysql&gt; select * from test_auto_increment;+----+| a |+----+| -1 | -- 刚刚插入的-1| 1 || 2 |+----+3 rows in set (0.00 sec)mysql&gt; insert into test_auto_increment values(NULL); -- 继续插入NULLQuery OK, 1 row affected (0.02 sec)mysql&gt; select * from test_auto_increment;+----+| a |+----+| -1 || 1 || 2 || 3 | -- 刚刚插入NULL， 自增为3+----+4 rows in set (0.00 sec)mysql&gt; insert into test_auto_increment values('0'); -- 插入字符0Query OK, 1 row affected (0.04 sec)mysql&gt; select * from test_auto_increment;+----+| a |+----+| -1 || 1 || 2 || 3 || 4 | -- 插入字符'0' 后， 自增长为4+----+5 rows in set (0.00 sec)mysql&gt; update test_auto_increment set a = 0 where a = -1; -- 更新为0Query OK, 1 row affected (0.03 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from test_auto_increment;+---+| a |+---+| 0 | -- 原来的 -1 更新为0| 1 || 2 || 3 || 4 |+---+5 rows in set (0.00 sec)---- 数字 0 这个值比较特殊， 插入0和插入NULL的效果是一样的，都是代表自增-------mysql&gt; insert into test_auto_increment values(NULL), (100), (NULL); Query OK, 3 rows affected (0.02 sec)Records: 3 Duplicates: 0 Warnings: 0mysql&gt; select * from test_auto_increment;+-----+| a |+-----+| 0 || 1 || 2 || 3 || 4 || 5 | -- 第一个NULL| 100 | -- 100| 101 | -- 第二个NULL, 按当前最大的值 +１来设置，之前是100，所以这里101+-----+8 rows in set (0.00 sec)mysql&gt; insert into test_auto_increment values(99); -- 插入99Query OK, 1 row affected (0.02 sec)mysql&gt; select * from test_auto_increment;+-----+| a |+-----+| 0 || 1 || 2 || 3 || 4 || 5 || 99 | -- 刚刚插入的 99| 100 || 101 |+-----+9 rows in set (0.00 sec) AUTO_INCREMENT是实例启动时，取当前表的最大值，然后 +1 即为下次自增的值。（MAX + 1) TIPS:insert into tablename select NULL; 等价与 insert into tablename values (NULL); 二. 数字类型1. 数字类型的分类 单精度类型：FLOAT 存储空间：4 字节 精确性：低 双精度类型：DOUBLE 占用空间：8 字节 精确性：低，比FLOAT高 高精度类型：DECIMAL 占用空间：变长 精确性：非常高 注意：财务系统必须使用DECIMAL 三. 字符串类型1. 字符串类型介绍 类型 说明 N的含义 是否有字符集 最大长度 CHAR(N) 定长字符 字符 是 255 VARCHAR(N) 变长字符 字符 是 16384 BINARY(N) 定长二进制字节 字节 否 255 VARBINARY(N) 变长二进制字节 字节 否 16384 TINYBLOB(N) 二进制大对象 字节 否 256 BLOB(N) 二进制大对象 字节 否 16K MEDIUMBLOB(N) 二进制大对象 字节 否 16M LONGBLOB(N) 二进制大对象 字节 否 4G TINYTEXT(N) 大对象 字节 是 256 TEXT(N) 大对象 字节 是 16K MEDIUMTEXT(N) 大对象 字节 是 16M LONGTEXT(N) 大对象 字节 是 4G 2. N和字符集 char(N) 假设当前table的字符集的最大长度为W, 则char(N)的最大存储空间为 (N X W)Byte;假设使用UTF-8，则char(10)可以最小存储10个字节的字符，最大存储30个字节的字符，其实是另一种意义上的varchar 当存储的字符数小于N时，尾部使用空格填充，并且填充最小字节的空格 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859mysql&gt; create table test_char(a char(10));Query OK, 0 rows affected (0.12 sec)mysql&gt; show create table test_char;+-----------+------------------------------------------------------------------------------------------------+| Table | Create Table |+-----------+------------------------------------------------------------------------------------------------+| test_char | CREATE TABLE `test_char` ( `a` char(10) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 |+-----------+------------------------------------------------------------------------------------------------+1 row in set (0.00 sec)mysql&gt; insert into test_char values('abc');Query OK, 1 row affected (0.02 sec)mysql&gt; insert into test_char values('你好吗');Query OK, 1 row affected (0.05 sec)mysql&gt; insert into test_char values('大家好ab');Query OK, 1 row affected (0.02 sec)mysql&gt; insert into test_char values('大家ab好');Query OK, 1 row affected (0.03 sec)mysql&gt; insert into test_char values('大家ab好吗');Query OK, 1 row affected (0.03 sec)mysql&gt; select a, length(a) from test_char;+----------------+-----------+| a | length(a) |+----------------+-----------+| abc | 3 || 你好吗 | 9 || 大家好ab | 11 || 大家ab好 | 11 || 大家ab好吗 | 14 |+----------------+-----------+5 rows in set (0.00 sec)mysql&gt; select a, hex(a) from test_char;+----------------+------------------------------+| a | hex(a) |+----------------+------------------------------+| abc | 616263 | -- 注意这里，以及下面的16进制值，一会可以对比| 你好吗 | E4BDA0E5A5BDE59097 || 大家好ab | E5A4A7E5AEB6E5A5BD6162 || 大家ab好 | E5A4A7E5AEB66162E5A5BD || 大家ab好吗 | E5A4A7E5AEB66162E5A5BDE59097 |+----------------+------------------------------+5 rows in set (0.00 sec)mysql&gt; select hex(' ');+----------+| hex(' ') |+----------+| 20 | -- 注意 空格 空格对应的16进制数字是 20+----------+1 row in set (0.00 sec) test_char表实际二进制存储文件 1234567891011121314151617181920212223242526-- -- shell&gt; hexdump -C test_char.idb---- 1:abc-- 2:你好吗-- 3:大家好ab-- 4:大家ab好-- 5:大家ab好吗-- ---省略---00006070 73 75 70 72 65 6d 75 6d 0a 00 00 00 10 00 24 00 |supremum......$.|00006080 00 00 00 02 03 00 00 00 00 1f 33 a8 00 00 00 26 |..........3....&amp;|00006090 01 10 61 62 63 20 20 20 20 20 20 20 0a 00 00 00 |..abc ....| -- 1:后面补了7个空格000060a0 18 00 24 00 00 00 00 02 04 00 00 00 00 1f 34 a9 |..$...........4.|000060b0 00 00 00 25 01 10 e4 bd a0 e5 a5 bd e5 90 97 20 |...%........... | -- 2:补充了1个空格000060c0 0b 00 00 00 20 00 25 00 00 00 00 02 05 00 00 00 |.... .%.........|000060d0 00 1f 39 ac 00 00 00 26 01 10 e5 a4 a7 e5 ae b6 |..9....&amp;........| -- 3:没有补充空格000060e0 e5 a5 bd 61 62 0b 00 00 00 28 00 25 00 00 00 00 |...ab....(.%....| -- 000060f0 02 06 00 00 00 00 1f 3a ad 00 00 00 28 01 10 e5 |.......:....(...| --00006100 a4 a7 e5 ae b6 61 62 e5 a5 bd 0e 00 00 00 30 ff |.....ab.......0.| -- 4：没有补充空格00006110 5f 00 00 00 00 02 07 00 00 00 00 1f 3f b0 00 00 |_...........?...|00006120 00 29 01 10 e5 a4 a7 e5 ae b6 61 62 e5 a5 bd e5 |.)........ab....|--00006130 90 97 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| -- 5：没有补充空格00006140 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|-- ---省略--- varchar(N)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051mysql&gt; create table test_varchar(a varchar(10));Query OK, 0 rows affected (0.12 sec)mysql&gt; show create table test_varchar;+--------------+------------------------------------------------------------------------------------------------------+| Table | Create Table |+--------------+------------------------------------------------------------------------------------------------------+| test_varchar | CREATE TABLE `test_varchar` ( `a` varchar(10) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 |+--------------+------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec)mysql&gt; insert into test_varchar values('abc');Query OK, 1 row affected (0.03 sec)mysql&gt; insert into test_varchar values('你好吗');Query OK, 1 row affected (0.02 sec)mysql&gt; insert into test_varchar values('大家好ab');Query OK, 1 row affected (0.03 sec)mysql&gt; insert into test_varchar values('大家ab好');Query OK, 1 row affected (0.02 sec)mysql&gt; insert into test_varchar values('大家ab好吗');Query OK, 1 row affected (0.03 sec)mysql&gt; select a, hex(a) from test_varchar;+----------------+------------------------------+| a | hex(a) |+----------------+------------------------------+| abc | 616263 || 你好吗 | E4BDA0E5A5BDE59097 || 大家好ab | E5A4A7E5AEB6E5A5BD6162 || 大家ab好 | E5A4A7E5AEB66162E5A5BD || 大家ab好吗 | E5A4A7E5AEB66162E5A5BDE59097 |+----------------+------------------------------+5 rows in set (0.00 sec)mysql&gt; select a, length(a) from test_varchar;+----------------+-----------+| a | length(a) |+----------------+-----------+| abc | 3 || 你好吗 | 9 || 大家好ab | 11 || 大家ab好 | 11 || 大家ab好吗 | 14 |+----------------+-----------+5 rows in set (0.00 sec) test_varchar表实际二进制存储文件 12345678910111213141516171819202122232425-- -- shell&gt; hexdump -C test_char.idb---- 1:abc-- 2:你好吗-- 3:大家好ab-- 4:大家ab好-- 5:大家ab好吗-- 和char一样观察，都没有进行空格的填充00006070 73 75 70 72 65 6d 75 6d 03 00 00 00 10 00 1d 00 |supremum........|00006080 00 00 00 02 08 00 00 00 00 1f 44 b5 00 00 00 29 |..........D....)|00006090 01 10 61 62 63 09 00 00 00 18 00 23 00 00 00 00 |..abc......#....| 000060a0 02 09 00 00 00 00 1f 45 b6 00 00 00 2b 01 10 e4 |.......E....+...|000060b0 bd a0 e5 a5 bd e5 90 97 0b 00 00 00 20 00 25 00 |............ .%.|000060c0 00 00 00 02 0a 00 00 00 00 1f 4a b9 00 00 00 2c |..........J....,|000060d0 01 10 e5 a4 a7 e5 ae b6 e5 a5 bd 61 62 0b 00 00 |...........ab...|000060e0 00 28 00 25 00 00 00 00 02 0b 00 00 00 00 1f 4b |.(.%...........K|000060f0 ba 00 00 00 2c 01 10 e5 a4 a7 e5 ae b6 61 62 e5 |....,........ab.|00006100 a5 bd 0e 00 00 00 30 ff 67 00 00 00 00 02 0c 00 |......0.g.......|00006110 00 00 00 1f 50 bd 00 00 00 2d 01 10 e5 a4 a7 e5 |....P....-......|00006120 ae b6 61 62 e5 a5 bd e5 90 97 00 00 00 00 00 00 |..ab............|00006130 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| 插入数据尾部带空格 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364mysql&gt; insert into test_char values('好好好 '); -- 后面有3个空格Query OK, 1 row affected (0.03 sec)mysql&gt; insert into test_varchar values('好好好 '); -- 后面有3个空格Query OK, 1 row affected (0.02 sec)-- -- test_char 表--mysql&gt; select a, length(a) from test_char; +----------------+-----------+| a | length(a) |+----------------+-----------+| abc | 3 || 你好吗 | 9 || 大家好ab | 11 || 大家ab好 | 11 || 大家ab好吗 | 14 || 好好好 | 9 | -- 只有9个字节+----------------+-----------+6 rows in set (0.00 sec)mysql&gt; select a, hex(a) from test_char;+----------------+------------------------------+| a | hex(a) |+----------------+------------------------------+| abc | 616263 || 你好吗 | E4BDA0E5A5BDE59097 || 大家好ab | E5A4A7E5AEB6E5A5BD6162 || 大家ab好 | E5A4A7E5AEB66162E5A5BD || 大家ab好吗 | E5A4A7E5AEB66162E5A5BDE59097 || 好好好 | E5A5BDE5A5BDE5A5BD | -- 无填充空格+----------------+------------------------------+6 rows in set (0.00 sec)---- test_varchar表--mysql&gt; select a, length(a) from test_varchar;+----------------+-----------+| a | length(a) |+----------------+-----------+| abc | 3 || 你好吗 | 9 || 大家好ab | 11 || 大家ab好 | 11 || 大家ab好吗 | 14 || 好好好 | 12 | -- (好好好)9个字节 + 3个字节的空格+----------------+-----------+7 rows in set (0.00 sec)mysql&gt; select a, hex(a) from test_varchar; +----------------+------------------------------+| a | hex(a) |+----------------+------------------------------+| abc | 616263 || 你好吗 | E4BDA0E5A5BDE59097 || 大家好ab | E5A4A7E5AEB6E5A5BD6162 || 大家ab好 | E5A4A7E5AEB66162E5A5BD || 大家ab好吗 | E5A4A7E5AEB66162E5A5BDE59097 || 好好好 | E5A5BDE5A5BDE5A5BD202020 | -- 后面有20 20 20 ，表示3个自己的空格+----------------+------------------------------+7 rows in set (0.00 sec) 上面的现象无法用统一的规则进行表述，但是官方文档给出的解释是，这样的安排是为了避免索引页的碎片 3.BLOB和TEXT 在BLOB和TEXT上创建索引时，必须指定索引前缀的长度 12345mysql&gt; create table test_text(a int primary key, b text, key(b));ERROR 1170 (42000): BLOB/TEXT column 'b' used in key specification without a key lengthmysql&gt; create table test_text(a int primary key, b text, key(b(64)));Query OK, 0 rows affected (0.13 sec) BLOB和TEXT列不能有默认值 BLOB和TEXT列排序时只使用该列的前max_sort_length个字节1234567mysql&gt; select @@max_sort_length;+-------------------+| @@max_sort_length |+-------------------+| 1024 |+-------------------+1 row in set (0.00 sec) 不建议在MySQL中存储大型的二进制数据，比如歌曲，视频 四. 字符集1. 常见的字符集 utf8 utf8mb4 gbk gb18030 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647mysql&gt; show character set;+----------+---------------------------------+---------------------+--------+| Charset | Description | Default collation | Maxlen |+----------+---------------------------------+---------------------+--------+| big5 | Big5 Traditional Chinese | big5_chinese_ci | 2 || dec8 | DEC West European | dec8_swedish_ci | 1 || cp850 | DOS West European | cp850_general_ci | 1 || hp8 | HP West European | hp8_english_ci | 1 || koi8r | KOI8-R Relcom Russian | koi8r_general_ci | 1 || latin1 | cp1252 West European | latin1_swedish_ci | 1 || latin2 | ISO 8859-2 Central European | latin2_general_ci | 1 || swe7 | 7bit Swedish | swe7_swedish_ci | 1 || ascii | US ASCII | ascii_general_ci | 1 || ujis | EUC-JP Japanese | ujis_japanese_ci | 3 || sjis | Shift-JIS Japanese | sjis_japanese_ci | 2 || hebrew | ISO 8859-8 Hebrew | hebrew_general_ci | 1 || tis620 | TIS620 Thai | tis620_thai_ci | 1 || euckr | EUC-KR Korean | euckr_korean_ci | 2 || koi8u | KOI8-U Ukrainian | koi8u_general_ci | 1 || gb2312 | GB2312 Simplified Chinese | gb2312_chinese_ci | 2 || greek | ISO 8859-7 Greek | greek_general_ci | 1 || cp1250 | Windows Central European | cp1250_general_ci | 1 || gbk | GBK Simplified Chinese | gbk_chinese_ci | 2 | -- gbk，表示的字符有限| latin5 | ISO 8859-9 Turkish | latin5_turkish_ci | 1 || armscii8 | ARMSCII-8 Armenian | armscii8_general_ci | 1 || utf8 | UTF-8 Unicode | utf8_general_ci | 3 | -- utf8，最长3字节| ucs2 | UCS-2 Unicode | ucs2_general_ci | 2 || cp866 | DOS Russian | cp866_general_ci | 1 || keybcs2 | DOS Kamenicky Czech-Slovak | keybcs2_general_ci | 1 || macce | Mac Central European | macce_general_ci | 1 || macroman | Mac West European | macroman_general_ci | 1 || cp852 | DOS Central European | cp852_general_ci | 1 || latin7 | ISO 8859-13 Baltic | latin7_general_ci | 1 || utf8mb4 | UTF-8 Unicode | utf8mb4_general_ci | 4 | -- utf8 + mobile端字符| cp1251 | Windows Cyrillic | cp1251_general_ci | 1 || utf16 | UTF-16 Unicode | utf16_general_ci | 4 || utf16le | UTF-16LE Unicode | utf16le_general_ci | 4 || cp1256 | Windows Arabic | cp1256_general_ci | 1 || cp1257 | Windows Baltic | cp1257_general_ci | 1 || utf32 | UTF-32 Unicode | utf32_general_ci | 4 || binary | Binary pseudo charset | binary | 1 || geostd8 | GEOSTD8 Georgian | geostd8_general_ci | 1 || cp932 | SJIS for Windows Japanese | cp932_japanese_ci | 2 || eucjpms | UJIS for Windows Japanese | eucjpms_japanese_ci | 3 || gb18030 | China National Standard GB18030 | gb18030_chinese_ci | 4 | -- gb18030,最长4个字节+----------+---------------------------------+---------------------+--------+41 rows in set (0.00 sec) 2. collationcollation的含义是指排序规则，ci（case insensitive）结尾的排序集是不区分大小写的12345678910111213141516171819202122232425mysql&gt; select 'a' = 'A';+-----------+| 'a' = 'A' |+-----------+| 1 | -- 因为大小写无关，所以返回1+-----------+1 row in set (0.00 sec)mysql&gt; create table test_ci (a varchar(10), key(a));Query OK, 0 rows affected (0.13 sec)mysql&gt; insert into test_ci values('a');Query OK, 1 row affected (0.02 sec)mysql&gt; insert into test_ci values('A');Query OK, 1 row affected (0.03 sec)mysql&gt; select * from test_ci where a = 'a';+------+| a |+------+| a | | A | -- A也被我们查到了+------+2 rows in set (0.00 sec) 上面的情况如果从业务的角度上看，可以很好理解，比如创建一个用户叫做Tom，你是不希望再创建一个叫做tom的用户的 修改默认的collation12345678910mysql&gt; set names utf8mb4 collate utf8mb4_bin; -- 当前会话有效Query OK, 0 rows affected (0.00 sec)mysql&gt; select 'a' = 'A';+-----------+| 'a' = 'A' |+-----------+| 0 |+-----------+1 row in set (0.00 sec) 字符集的指定，可以在创建数据库的时候指定，也可以在创建表的时候单独指定，也可以创建列的时候进行指定 五. 集合类型 集合类型ENUM 和 SET ENUM类型最多允许65536个值 SET类型最多允许64个值 通过sql_mode参数可以用户约束检查 1. 集合类型的排序12345678910111213141516mysql&gt; create table test_col ( -&gt; user varchar(10), -&gt; sex enum('male', 'female') -- 虽然写的是字符串，单其实存储的整型，效率还是可以的 -&gt; ); mysql&gt; insert into test_col values ("tom", "male");Query OK, 1 row affected (0.02 sec)mysql&gt; insert into test_col values ("tom", "xmale"); -- 不是male 和 femaleQuery OK, 1 row affected, 1 warning (0.03 sec) -- 有warningmysql&gt; set sql_mode='strict_trans_tables'; -- 设置为严格模式Query OK, 0 rows affected, 2 warnings (0.00 sec)mysql&gt; insert into test_col values ("tom", "xmale");ERROR 1265 (01000): Data truncated for column 'sex' at row 1 强烈建议新业务上都设置成严格模式 2. 集合类型的排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051mysql&gt; create table test_col_sort( -&gt; user char(10), -&gt; type enum('aaa','zzz','bbb','yyy','fff') -- aaa=0, zzz=1, bbb=2, yyy=3, fff=4 -&gt; );Query OK, 0 rows affected (0.20 sec)mysql&gt; select * from test_col_sort order by type asc; -- 以type作为key，进行升序排序+-------+------+| user | type |+-------+------+| user1 | aaa | -- 0| user4 | zzz | -- 1| user2 | bbb | -- 2| user3 | yyy | -- 3+-------+------+ -- 枚举类型实际是整型数据，按照插入顺序进行排列4 rows in set (0.00 sec)---- 使用ascii排序--mysql&gt; select * from test_col_sort order by cast(type as char) asc; -- 使用cast()函数转换成某种型+-------+------+ -- 这里我们转成char型| user | type | -- 然后进行排序(ascii)+-------+------+| user1 | aaa | -- 0| user2 | bbb | -- 2| user3 | yyy | -- 3| user4 | zzz | -- 1+-------+------+4 rows in set (0.00 sec)-- 或者使用concatmysql&gt; select * from test_col_sort order by concat(type) asc; -- concat()是连接字符串函数 +-------+------+| user | type |+-------+------+| user1 | aaa | -- 0| user2 | bbb | -- 2| user3 | yyy | -- 3| user4 | zzz | -- 1+-------+------+4 rows in set (0.00 sec)mysql&gt; select concat("abc", "大家好");+----------------------------+| concat("abc", "大家好") |+----------------------------+| abc大家好 |+----------------------------+1 row in set (0.00 sec) 六. 日期类型 日期类型 占用空间(byte)（&lt;5.6） 占用空间(byte)(&gt;=5.6) 表示范围 DATETIME 8 5 + 微秒存储空间 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 DATE 3 3 1000-01-01 ~ 9999-12-31 TIMESTAMP 4 4 + 微秒存储空间 1970-01-01 00:00:00UTC ~ 2038-01-19 03:14:07UTC YEAR 1 1 YEAR(2):1970-2070, YEAR(4):1901-2155 TIME 3 3 + 微秒存储空间 -838:59:59 ~ 838:59:59 微秒位数 所需存储空间 0 0 1, 2 1 byte 3, 4 2 bytes 5, 6 3 bytes TIMESTAMP 带时区功能 1. TIMESTAMP和DATETIME12345678910111213141516171819202122232425262728293031323334353637383940mysql&gt; create table test_time(a timestamp, b datetime);Query OK, 0 rows affected (0.12 sec)mysql&gt; insert into test_time values (now(), now());Query OK, 1 row affected (0.03 sec)mysql&gt; select * from test_time;+---------------------+---------------------+| a | b |+---------------------+---------------------+| 2015-11-28 10:00:39 | 2015-11-28 10:00:39 |+---------------------+---------------------+1 row in set (0.00 sec)mysql&gt; select @@time_zone; +-------------+| @@time_zone |+-------------+| SYSTEM |+-------------+1 row in set (0.00 sec)mysql&gt; set time_zone='+00:00';Query OK, 0 rows affected (0.00 sec)mysql&gt; select @@time_zone;+-------------+| @@time_zone |+-------------+| +00:00 |+-------------+1 row in set (0.00 sec)mysql&gt; select * from test_time;+---------------------+---------------------+| a | b |+---------------------+---------------------+| 2015-11-28 2:00:39 | 2015-11-28 10:00:39 | -- 时区的差别体现出来了+---------------------+---------------------+1 row in set (0.00 sec) 2. 微秒从MySQL5.6.X开始，支持微秒，最大显示6位123456789101112131415161718192021222324mysql&gt; select now(6);+----------------------------+| now(6) |+----------------------------+| 2015-11-30 21:15:36.415358 | -- 6位 微秒显示+----------------------------+1 row in set (0.00 sec)mysql&gt; select now(7);ERROR 1426 (42000): Too-big precision 7 specified for 'now'. Maximum is 6. -- 不支持，最大到6mysql&gt; create table test_time_fac (t datetime(6));Query OK, 0 rows affected (0.11 sec)mysql&gt; insert into test_time_fac values(now(6)); Query OK, 1 row affected (0.02 sec)mysql&gt; select * from test_time_fac;+----------------------------+| t |+----------------------------+| 2015-11-30 21:19:27.900393 | -- 由于是用了6位微秒位数，根据表格显示，实际存储的空间是 5 + 3 = 8 byte+----------------------------+1 row in set (0.00 sec) 3. 时间函数 常用函数| 函数名 | 函数说明 | 备注 ||——–|———-|——|| NOW | 返回SQL执行时的时间| 如果不考虑其他因素，可以理解为写完SQL，敲下回车瞬间的时间 || CURRENT_TIMESTAMP| 与NOW()函数同义||| SYSDATE | 返回函数执行时的时间|MySQL处理你的函数时的时间，统一SQL语句中，大于NOW|| DATA_ADD(date, interval expr uint) | 增加时间||| DATA_SUB(date, interval expr uint) | 减少时间|可用ADD，然后unit给负数|| DATE FORMAT| 格式化时间| | 所有时间函数–官方文档 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556---- NOW和SYSDATE的区别--mysql&gt; select now(6),sysdate(6),sleep(5),now(6),sysdate(6);+----------------------------+----------------------------+----------+----------------------------+----------------------------+| now(6) | sysdate(6) | sleep(5) | now(6) | sysdate(6) |+----------------------------+----------------------------+----------+----------------------------+----------------------------+| 2015-11-30 21:40:58.572383 | 2015-11-30 21:40:58.572542 | 0 | 2015-11-30 21:40:58.572383 | 2015-11-30 21:41:03.572720 |+----------------------------+----------------------------+----------+----------------------------+----------------------------+1 row in set (5.00 sec)---- 两个now(6)都相等，因为是SQL执行时的时间(可以简单立理解为按回车的时间)-- 两个sysdate(6)差了5秒，刚好是sleep(5)的时间----------- date_add--mysql&gt; select date_add(now(), interval 5 day); -- 增加5天+---------------------------------+| date_add(now(), interval 5 day) |+---------------------------------+| 2015-12-05 21:42:39 |+---------------------------------+1 row in set (0.00 sec)mysql&gt; select date_add(now(), interval -5 month); -- 减少 5个月+------------------------------------+| date_add(now(), interval -5 month) |+------------------------------------+| 2015-06-30 21:43:49 |+------------------------------------+1 row in set (0.00 sec)mysql&gt; select date_sub(now(), interval 5 month); -- 与add + 负数一致+-----------------------------------+| date_sub(now(), interval 5 month) |+-----------------------------------+| 2015-06-30 21:44:21 |+-----------------------------------+1 row in set (0.00 sec)---- date_format--mysql&gt; SELECT DATE_FORMAT((select now(6)), '%H:%i:%s');+------------------------------------------+| DATE_FORMAT((select now(6)), '%H:%i:%s') |+------------------------------------------+| 21:48:30 |+------------------------------------------+1 row in set (0.00 sec) 4. 字段更新时间12345678910111213141516171819202122232425262728293031323334353637383940414243444546mysql&gt; create table test_field_update( -&gt; a int(10), -&gt; b timestamp not null default current_timestamp on update current_timestamp -&gt; );mysql&gt; insert into test_field_update values(1, now(6));Query OK, 1 row affected (0.03 sec)mysql&gt; select * from test_field_update;+------+---------------------+| a | b |+------+---------------------+| 1 | 2015-11-30 21:55:18 | -- 上面使用了now(6)，但是这里没有微秒，是因为定义的时候就是timestamp+------+---------------------+ -- 如果写成timestamp(6),就可以显示微秒1 row in set (0.00 sec)mysql&gt; update test_field_update set a=100 where a=1; -- 只更新a字段Query OK, 1 row affected (0.03 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from test_field_update; +------+---------------------+| a | b |+------+---------------------+| 100 | 2015-11-30 22:01:03 | -- 发现b字段跟着改变了+------+---------------------+1 row in set (0.00 sec)---- 测试timestamp(6)--mysql&gt; create table test_time_disp( -&gt; a int(10), -&gt; b timestamp(6) not null default current_timestamp(6) on update current_timestamp(6) -- 定义了(6) -&gt; );mysql&gt; insert into test_time_disp values(1, now(6)); Query OK, 1 row affected (0.02 sec)mysql&gt; select * from test_time_disp;+------+----------------------------+| a | b |+------+----------------------------+| 1 | 2015-11-30 22:03:23.545406 | -- 插入了now(6), 这里就显示了6位微秒+------+----------------------------+1 row in set (0.00 sec)]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记（Day007：多实例下/SSL）]]></title>
    <url>%2F2018%2F05%2F30%2FMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(Day007)%2F</url>
    <content type="text"><![CDATA[MySQL学习笔记（Day007：多实例下/SSL）@(MySQL学习) [TOC] 一. 多实例安装 – 多版本1. [mysqld_multi]标签 [mysqld_multi] 是否需要配置从操作演示来看，在my.cnf(老师给的模板配置)上直接配置[mysqld1]、[mysqld2]等实例标签，而不配置[mysqld_multi],使用mysqld_multi start 1也是可以启动数据库实例的，但是没有mysqld_safe的守护进程。所以该标签需要配置 2. 停止mysql实例 multi_admin用户的作用通过官方文档中我们看到，&#39;multi_admin&#39;@&#39;localhost&#39;这个用户主要的作用是用来关闭数据库实例，因为文档中只授权了SHUTDOWN权限。所以在[mysqld_multi]标签下，我们需要配置user和password(注意5.7.9中是pass)来进行关闭数据库实例。 [client]标签从操作演示来看，老师并没有在[mysqld_multi]下配置user和password，但是仍然可以关闭数据库，原因是因为/root/.my.cnf中存在了[client]标签。该标签下的用户user = root有关闭数据库实例的权限，因此可以关闭数据库。 如果在[client]和[mysqld_multi]标签中同时存在user和password, 则在关闭数据库实例中会使用[mysqld_multi]中的user去关闭。(存在精确匹配的标签，则优先使用精确匹配标签下的配置项) 3. 多实例安装 – 多版本 环境说明 mysqld1 – MySQL 5.7.9 mysqld2 – MySQL 5.7.9 mysqld3 – MySQL 5.6.27 mysqld4 – MySQL 5.6.27 配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132[client]user = rootpassword = 123[mysqld_multi] # 这里使用了client标签中的user，故这里不再定义usermysqld = /usr/local/mysql/bin/mysqld_safelog = /var/log/mysqld_multi.log[mysqld1]server-id = 11datadir = /data1basedir = /usr/local/mysql # basedir定义使用了5.7的mysql版本port = 3307socket = /tmp/mysql.sock1[mysqld2]server-id = 22datadir = /data2basedir = /usr/local/mysqlport = 3308socket = /tmp/mysql.sock2[mysqld3]server-id = 33datadir = /data3basedir = /usr/local/mysql56 # basedir定义了使用5.6的mysql版本port = 3309socket = /tmp/mysql.sock3plugin_dir=/usr/local/mysql56/lib/plugin # plugin 目录也变了#这里无需特别配置mysqld, 可以继承使用[mysqld_multi]中的配置，然后根据basedir找到对应的mysqld[mysqld4]server-id = 44datadir = /data4basedir = /usr/local/mysql56port = 3310socket = /tmp/mysql.sock4plugin_dir=/usr/local/mysql56/lib/plugin#--------------以下参数是老师的模板，只是将个别size调小-----------[mysqld]########basic settings########server-id = 100port = 3306user = mysqlbind_address = 0.0.0.0#autocommit = 0character_set_server=utf8mb4skip_name_resolve = 1max_connections = 800max_connect_errors = 1000datadir = /data/mysql_datatransaction_isolation = READ-COMMITTEDexplicit_defaults_for_timestamp = 1join_buffer_size = 134217728tmp_table_size = 67108864tmpdir = /tmpmax_allowed_packet = 16777216sql_mode = "STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER"interactive_timeout = 1800wait_timeout = 1800read_buffer_size = 16777216read_rnd_buffer_size = 33554432sort_buffer_size = 33554432########log settings########log_error = error.logslow_query_log = 1slow_query_log_file = slow.loglog_queries_not_using_indexes = 1log_slow_admin_statements = 1log_slow_slave_statements = 1log_throttle_queries_not_using_indexes = 10expire_logs_days = 90long_query_time = 2min_examined_row_limit = 100########replication settings########master_info_repository = TABLErelay_log_info_repository = TABLElog_bin = bin.logsync_binlog = 1gtid_mode = onenforce_gtid_consistency = 1log_slave_updatesbinlog_format = row relay_log = relay.logrelay_log_recovery = 1binlog_gtid_simple_recovery = 1slave_skip_errors = ddl_exist_errors########innodb settings########innodb_page_size = 8192innodb_buffer_pool_size = 1G # 该参数减小到1Ginnodb_buffer_pool_instances = 8innodb_buffer_pool_load_at_startup = 1innodb_buffer_pool_dump_at_shutdown = 1innodb_lru_scan_depth = 2000innodb_lock_wait_timeout = 5innodb_io_capacity = 4000innodb_io_capacity_max = 8000innodb_flush_method = O_DIRECTinnodb_file_format = Barracudainnodb_file_format_max = Barracuda#innodb_log_group_home_dir = /redolog/#innodb_undo_directory = /undolog/innodb_undo_logs = 128innodb_undo_tablespaces = 3innodb_flush_neighbors = 1innodb_log_file_size = 128M # 该参数减小到 128Minnodb_log_buffer_size = 16777216innodb_purge_threads = 4innodb_large_prefix = 1innodb_thread_concurrency = 64innodb_print_all_deadlocks = 1innodb_strict_mode = 1innodb_sort_buffer_size = 67108864 ########semi sync replication settings########plugin_dir=/usr/local/mysql/lib/plugin#plugin_load = "rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so"loose_rpl_semi_sync_master_enabled = 1loose_rpl_semi_sync_slave_enabled = 1loose_rpl_semi_sync_master_timeout = 5000[mysqld-5.7]innodb_buffer_pool_dump_pct = 40innodb_page_cleaners = 4innodb_undo_log_truncate = 1innodb_max_undo_log_size = 1G # 该参数减小到1Ginnodb_purge_rseg_truncate_frequency = 128binlog_gtid_simple_recovery=1log_timestamps=systemtransaction_write_set_extraction=MURMUR32show_compatibility_56=on 注意MySQL5.6.27的plugin_dir的路径 配置说明：1：配置的标签顺序没有关系，不会影响最终配置的有效性。2：同类型标签中的配置项会合并，形成一个大的配置项2：匹配度高的标签中的配置项的值，会覆盖掉匹配度低的标签中的配置项的值 [mysqldN]中的配置项会和[mysqld]中的配置项进行合并，并且[mysqldN]中已有的配置项的值，会覆盖掉[mysqld]中的配置项的值,如datadir, port等 安装操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970## 准备好数据目录，并初始化安装#[root@MyServer ~]&gt; mkdir /data1[root@MyServer ~]&gt; mkdir /data2[root@MyServer ~]&gt; mkdir /data3[root@MyServer ~]&gt; mkdir /data4[root@MyServer ~]&gt; chown mysql.mysql /data&#123;1..4&#125;[root@MyServer ~]&gt; mysqld --initialize --user=mysql --datadir=/data1## 这里无输出，临时密码见 /data1/error.log#[root@MyServer ~]&gt; mysqld --initialize --user=mysql --datadir=/data2## 这里无输出，临时密码见 /data1/error.log#[root@MyServer mysql56]&gt; pwd/usr/local/mysql56[root@MyServer mysql56]&gt; scripts/mysql_install_db --user=mysql --datadir=/data3## 这里有部分信息输出# 安装后，需要检查error.log 确保没有错误出现# 注意使用空密码登录后，修改密码#[root@MyServer mysql56]&gt; scripts/mysql_install_db --user=mysql --datadir=/data4## 这里有部分信息输出# 安装后，需要检查error.log 确保没有错误出现# 注意使用空密码登录后，修改密码#[root@MyServer ~]&gt; cp /usr/local/mysql/support-files/mysqld_multi.server /etc/init.d/mysqld_multid # 拷贝启动脚本，方便自启[root@MyServer ~]&gt; chkconfig mysqld_multid on[root@MyServer ~]&gt; mysqld_multi report Reporting MySQL serversMySQL server from group: mysqld1 is not runningMySQL server from group: mysqld2 is not runningMySQL server from group: mysqld3 is not runningMySQL server from group: mysqld4 is not running[root@MyServer ~]&gt; mysqld_multi reportReporting MySQL serversMySQL server from group: mysqld1 is runningMySQL server from group: mysqld2 is runningMySQL server from group: mysqld3 is runningMySQL server from group: mysqld4 is running[root@MyServer ~]&gt; ps -ef | grep mysqldroot 13859 1 0 22:35 pts/1 00:00:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --server-id=11 --datadir=/data1 --basedir=/usr/local/mysql --port=3307 --socket=/tmp/mysql.sock1root 13865 1 0 22:35 pts/1 00:00:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --server-id=22 --datadir=/data2 --basedir=/usr/local/mysql --port=3308 --socket=/tmp/mysql.sock2root 13872 1 0 22:35 pts/1 00:00:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --server-id=33 --datadir=/data3 --basedir=/usr/local/mysql56 --port=3309 --socket=/tmp/mysql.sock3 --plugin_dir=/usr/local/mysql56/lib/pluginroot 13886 1 0 22:35 pts/1 00:00:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --server-id=44 --datadir=/data4 --basedir=/usr/local/mysql56 --port=3310 --socket=/tmp/mysql.sock4 --plugin_dir=/usr/local/mysql56/lib/plugin## 上面是mysqld_safe的守护进程# 下面是实际的mysqld的进程，观察mysqld的路径# 因为指定了basedir，所以会自动识别mysqld的路径#mysql 17783 13859 0 22:35 pts/1 00:00:00 /usr/local/mysql-5.7.9-linux-glibc2.5-x86_64/bin/mysqld --basedir=/usr/local/mysql --datadir=/data1 --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --server-id=11 --log-error=/data1/error.log --pid-file=/data1/MyServer.pid --socket=/tmp/mysql.sock1 --port=3307mysql 17784 13865 0 22:35 pts/1 00:00:00 /usr/local/mysql-5.7.9-linux-glibc2.5-x86_64/bin/mysqld --basedir=/usr/local/mysql --datadir=/data2 --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --server-id=22 --log-error=/data2/error.log --pid-file=/data2/MyServer.pid --socket=/tmp/mysql.sock2 --port=3308mysql 17819 13872 0 22:35 pts/1 00:00:00 /usr/local/mysql-5.6.27-linux-glibc2.5-x86_64/bin/mysqld --basedir=/usr/local/mysql56 --datadir=/data3 --plugin-dir=/usr/local/mysql56/lib/plugin --user=mysql --server-id=33 --log-error=/data3/error.log --pid-file=/data3/MyServer.pid --socket=/tmp/mysql.sock3 --port=3309mysql 17824 13886 0 22:35 pts/1 00:00:00 /usr/local/mysql-5.6.27-linux-glibc2.5-x86_64/bin/mysqld --basedir=/usr/local/mysql56 --datadir=/data4 --plugin-dir=/usr/local/mysql56/lib/plugin --user=mysql --server-id=44 --log-error=/data4/error.log --pid-file=/data4/MyServer.pid --socket=/tmp/mysql.sock4 --port=3310root 17988 2657 0 22:44 pts/1 00:00:00 grep mysqld[root@MyServer ~]&gt; ps -ef | grep mysqld | grep -v mysqld_safe | grep -v grep | awk '&#123;print $8" "$9&#125;' /usr/local/mysql-5.7.9-linux-glibc2.5-x86_64/bin/mysqld --basedir=/usr/local/mysql/usr/local/mysql-5.7.9-linux-glibc2.5-x86_64/bin/mysqld --basedir=/usr/local/mysql/usr/local/mysql-5.6.27-linux-glibc2.5-x86_64/bin/mysqld --basedir=/usr/local/mysql56/usr/local/mysql-5.6.27-linux-glibc2.5-x86_64/bin/mysqld --basedir=/usr/local/mysql56 mysql3 和 mysql4初始状态没有密码，以前可以直接使用mysql -S mysql.sock登录，而现在登录的时候特别注意，因为我们使用了[client]标签,登录的时候如果不加-p参数会默认使用标签下的user和password, 然后导致登录不进去，所以需要使用如下登录方式： 123456789101112131415shell&gt; mysql -u root -P3309 -S /tmp/mysql.sock3 -pEnter password: [直接回车]elcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 3Server version: 5.6.27-log MySQL Community Server (GPL)Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; set password = password("123"); #进行修改密码 设置login-path设置login-path主要为了能够简化登录，同时还可以让每个数据库的密码都不同，避免使用[client]下的统一用户名密码123456[root@MyServer ~]&gt; mysql_config_editor set -G mysql1 -u root -p -S /tmp/mysql.sock1[root@MyServer ~]&gt; mysql_config_editor set -G mysql2 -u root -p -S /tmp/mysql.sock2[root@MyServer ~]&gt; mysql_config_editor set -G mysql3 -u root -p -S /tmp/mysql.sock3[root@MyServer ~]&gt; mysql_config_editor set -G mysql4 -u root -p -S /tmp/mysql.sock4# 然后可以使用mysql --login-path=mysql1 这种方式登录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475---- mysql1 --mysql&gt; select version();+-----------+| version() |+-----------+| 5.7.9-log |+-----------+1 row in set (0.01 sec)mysql&gt; show variables like "port"; +---------------+-------+| Variable_name | Value |+---------------+-------+| port | 3307 |+---------------+-------+1 row in set (0.00 sec)---- mysql2--mysql&gt; select version();+-----------+| version() |+-----------+| 5.7.9-log |+-----------+1 row in set (0.00 sec)mysql&gt; show variables like "port";+---------------+-------+| Variable_name | Value |+---------------+-------+| port | 3308 |+---------------+-------+1 row in set (0.00 sec)---- mysql3--mysql&gt; select version();+------------+| version() |+------------+| 5.6.27-log | -- mysql 5.6.27 +------------+1 row in set (0.00 sec)mysql&gt; show variables like "port";+---------------+-------+| Variable_name | Value |+---------------+-------+| port | 3309 |+---------------+-------+1 row in set (0.00 sec)---- mysql4--mysql&gt; select version();+------------+| version() |+------------+| 5.6.27-log | -- mysql 5.6.27+------------+1 row in set (0.00 sec)mysql&gt; show variables like "port";+---------------+-------+| Variable_name | Value |+---------------+-------+| port | 3310 |+---------------+-------+1 row in set (0.00 sec) 二. SSL安装SSL（Secure Socket Layer）是维护Client - Server之间加密通讯的一套安全协议； 1234567891011121314151617181920212223mysql&gt; show variables like "port";+---------------+-------+| Variable_name | Value |+---------------+-------+| port | 3307 |+---------------+-------+1 row in set (0.00 sec)mysql&gt; show variables like "%ssl%";+---------------+----------+| Variable_name | Value |+---------------+----------+| have_openssl | DISABLED | -- SSL被禁止了| have_ssl | DISABLED || ssl_ca | || ssl_capath | || ssl_cert | || ssl_cipher | || ssl_crl | || ssl_crlpath | || ssl_key | |+---------------+----------+9 rows in set (0.00 sec) 经过之前的多实例安装，是没有开启SSL配置的 1. 开启SSL (5.7.9) 环境说明 虚拟机1：MyServer； IP：172.18.14.68, MySQL实例1 - mysql1 虚拟机2：MyServer； IP：172.18.14.41, MySQL客户端 操作过程中看到的192.168.115.223 是宿主机IP，因为使用KVM虚拟机的NAT功能，所以会被转换 123456789101112131415161718192021## 当前虚拟机1 MyServer#[root@MyServer mysql]&gt; pwd/usr/local/mysql[root@MyServer mysql]&gt; bin/mysql_ssl_rsa_setup --datadir=/data1 --user=mysql --uid=mysql # 使用--uid后，就不需要chown mysql.mysql *.pem[root@MyServer data1]# pwd/data1[root@MyServer data1]# ll | grep pem-rw-------. 1 mysql mysql 1675 Nov 25 23:55 ca-key.pem-rw-r--r--. 1 mysql mysql 1070 Nov 25 23:55 ca.pem-rw-r--r--. 1 mysql mysql 1078 Nov 25 23:55 client-cert.pem #客户端证书文件-rw-------. 1 mysql mysql 1679 Nov 25 23:55 client-key.pem #客户端私钥文件-rw-------. 1 mysql mysql 1675 Nov 25 23:55 private_key.pem #用于密钥交换的公钥-rw-r--r--. 1 mysql mysql 451 Nov 25 23:55 public_key.pem #用户密钥交换的私钥-rw-r--r--. 1 mysql mysql 1078 Nov 25 23:55 server-cert.pem #服务器端证书文件-rw-------. 1 mysql mysql 1679 Nov 25 23:55 server-key.pem #服务器端私钥文件[root@MyServer data1]&gt; mysqld_multi stop 1[root@MyServer data1]&gt; mysqld_multi start 1 关于几个pem文件的用途说面，见官方文档，并搜索关键字private/public key-pair 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105---- 当前虚拟机1 MyServer ,当前实例为 mysql1--mysql&gt; show variables like "port";+---------------+-------+| Variable_name | Value |+---------------+-------+| port | 3307 |+---------------+-------+1 row in set (0.00 sec)mysql&gt; show variables like "%ssl%";+---------------+-----------------+| Variable_name | Value |+---------------+-----------------+| have_openssl | YES | -- 已经支持SSL| have_ssl | YES || ssl_ca | ca.pem || ssl_capath | || ssl_cert | server-cert.pem | -- 公钥文件| ssl_cipher | || ssl_crl | || ssl_crlpath | || ssl_key | server-key.pem | -- 私钥文件+---------------+-----------------+9 rows in set (0.00 sec)mysql&gt; \s -- status--------------mysql Ver 14.14 Distrib 5.7.9, for linux-glibc2.5 (x86_64) using EditLine wrapperConnection id: 2Current database:Current user: root@localhostSSL: Not in use -- 此时本地socket登录，不用SSLCurrent pager: stdoutUsing outfile: ''Using delimiter: ;Server version: 5.7.9-log MySQL Community Server (GPL)Protocol version: 10Connection: Localhost via UNIX socketServer characterset: utf8mb4Db characterset: utf8mb4Client characterset: utf8Conn. characterset: utf8UNIX socket: /tmp/mysql.sock1Uptime: 6 min 16 secThreads: 1 Questions: 7 Slow queries: 0 Opens: 108 Flush tables: 1 Open tables: 101 Queries per second avg: 0.018--------------mysql&gt; create user 'burn'@'%' identified by '123'; -- 创建一个burn@%用户，先不require sslQuery OK, 0 rows affected (0.02 sec)mysql&gt; grant all on *.* to 'burn'@'%';Query OK, 0 rows affected (0.01 sec)mysql&gt; select * from mysql.user where user='burn'\G*************************** 1. row *************************** Host: % User: burn Select_priv: Y Insert_priv: Y Update_priv: Y Delete_priv: Y Create_priv: Y Drop_priv: Y Reload_priv: Y Shutdown_priv: Y Process_priv: Y File_priv: Y Grant_priv: N References_priv: Y Index_priv: Y Alter_priv: Y Show_db_priv: Y Super_priv: Y Create_tmp_table_priv: Y Lock_tables_priv: Y Execute_priv: Y Repl_slave_priv: Y Repl_client_priv: Y Create_view_priv: Y Show_view_priv: Y Create_routine_priv: Y Alter_routine_priv: Y Create_user_priv: Y Event_priv: Y Trigger_priv: YCreate_tablespace_priv: Y ssl_type: -- 此处为空 ssl_cipher: x509_issuer: x509_subject: max_questions: 0 max_updates: 0 max_connections: 0 max_user_connections: 0 plugin: mysql_native_password authentication_string: *23AE809DDACAF96AF0FD78ED04B6A265E05AA257 password_expired: N password_last_changed: 2015-11-26 09:55:31 password_lifetime: NULL account_locked: N1 row in set (0.00 sec) 12345678910111213141516171819202122232425262728293031323334353637383940## 当前虚拟机2 MyServer2#[root@MyServer2 bin]&gt; ./mysql -u burn -h 172.18.14.68 -P3307 -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 6Server version: 5.7.9-log MySQL Community Server (GPL)Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; \s--------------./mysql Ver 14.14 Distrib 5.7.9, for linux-glibc2.5 (x86_64) using EditLine wrapperConnection id: 6Current database:Current user: burn@192.168.115.223SSL: Cipher in use is DHE-RSA-AES256-SHA #已经使用了ssl登录了Current pager: stdoutUsing outfile: ''Using delimiter: ;Server version: 5.7.9-log MySQL Community Server (GPL)Protocol version: 10Connection: 172.18.14.68 via TCP/IPServer characterset: utf8mb4Db characterset: utf8mb4Client characterset: utf8Conn. characterset: utf8TCP port: 3307Uptime: 3 min 6 secThreads: 2 Questions: 19 Slow queries: 0 Opens: 109 Flush tables: 1 Open tables: 102 Queries per second avg: 0.102-------- 123456789## 当前虚拟机2 MyServer2# 上面测试中我们没有使用--ssl参数，也是用了ssl登录的，原因如下#[root@MyServer2 bin]&gt; ./mysql --help | grep ssl --ssl If set to ON, this option enforces that SSL is server. To disable client SSL capabilities use --ssl=OFF. (Defaults to on; use --skip-ssl to disable.) # 这里说，默认是开启的，可以用--skip-ssl 禁用 1234567891011121314151617181920212223242526272829303132333435363738394041## 当前虚拟机2 MyServer2 # 禁用ssl登录测试#[root@MyServer2 bin]&gt; ./mysql -u burn -h 172.18.14.68 -P3307 -p --skip-ssl #这里跳过了sslEnter password: Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 7Server version: 5.7.9-log MySQL Community Server (GPL)Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; \s--------------./mysql Ver 14.14 Distrib 5.7.9, for linux-glibc2.5 (x86_64) using EditLine wrapperConnection id: 7Current database:Current user: burn@192.168.115.223SSL: Not in use # 果然就禁用了sslCurrent pager: stdoutUsing outfile: ''Using delimiter: ;Server version: 5.7.9-log MySQL Community Server (GPL)Protocol version: 10Connection: 172.18.14.68 via TCP/IPServer characterset: utf8mb4Db characterset: utf8mb4Client characterset: utf8Conn. characterset: utf8TCP port: 3307Uptime: 5 min 50 secThreads: 2 Questions: 24 Slow queries: 0 Opens: 109 Flush tables: 1 Open tables: 102 Queries per second avg: 0.068-------------- 1234567891011121314---- 当前虚拟机1 MyServer, 当前实例mysql1-- 让用户必须使用ssl--mysql&gt; show variables like "port";+---------------+-------+| Variable_name | Value |+---------------+-------+| port | 3307 |+---------------+-------+1 row in set (0.00 sec)mysql&gt; alter user 'burn'@'%' require ssl;Query OK, 0 rows affected (0.02 sec) 1234567891011121314151617181920212223242526272829303132333435363738394041424344## 当前虚拟机2 MyServer2#[root@MyServer2 bin]&gt; ./mysql -u burn -h 172.18.14.68 -P3307 -p --skip-sslEnter password: ERROR 1045 (28000): Access denied for user 'burn'@'192.168.115.223' (using password: YES) ## 禁用了SSL就无法登录了##[root@MyServer2 bin]&gt; ./mysql -u burn -h 172.18.14.68 -P3307 -p # 默认就启用sslEnter password: Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 9Server version: 5.7.9-log MySQL Community Server (GPL)Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; \s--------------./mysql Ver 14.14 Distrib 5.7.9, for linux-glibc2.5 (x86_64) using EditLine wrapperConnection id: 9Current database:Current user: burn@192.168.115.223SSL: Cipher in use is DHE-RSA-AES256-SHA # 确实启用了Current pager: stdoutUsing outfile: ''Using delimiter: ;Server version: 5.7.9-log MySQL Community Server (GPL)Protocol version: 10Connection: 172.18.14.68 via TCP/IPServer characterset: utf8mb4Db characterset: utf8mb4Client characterset: utf8Conn. characterset: utf8TCP port: 3307Uptime: 14 min 25 secThreads: 2 Questions: 32 Slow queries: 0 Opens: 109 Flush tables: 1 Open tables: 102 Queries per second avg: 0.036-------------- 2. 开启证书认证(5.7.9)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465---- 当前虚拟机1 MyServer， 当前实例 msyql1--mysql&gt; show variables like "port";+---------------+-------+| Variable_name | Value |+---------------+-------+| port | 3307 |+---------------+-------+1 row in set (0.00 sec)mysql&gt; create user 'burn_x509'@'%' identified by '123' require x509; -- 启用证书认证Query OK, 0 rows affected (0.02 sec)mysql&gt; grant all on *.* to 'burn'@'%';Query OK, 0 rows affected (0.01 sec)mysql&gt; select * from mysql.user where user='burn_x509'\G*************************** 1. row *************************** Host: % User: burn_x509 Select_priv: N Insert_priv: N Update_priv: N Delete_priv: N Create_priv: N Drop_priv: N Reload_priv: N Shutdown_priv: N Process_priv: N File_priv: N Grant_priv: N References_priv: N Index_priv: N Alter_priv: N Show_db_priv: N Super_priv: N Create_tmp_table_priv: N Lock_tables_priv: N Execute_priv: N Repl_slave_priv: N Repl_client_priv: N Create_view_priv: N Show_view_priv: N Create_routine_priv: N Alter_routine_priv: N Create_user_priv: N Event_priv: N Trigger_priv: NCreate_tablespace_priv: N ssl_type: X509 -- 使用X509登录 ssl_cipher: x509_issuer: x509_subject: max_questions: 0 max_updates: 0 max_connections: 0 max_user_connections: 0 plugin: mysql_native_password authentication_string: *23AE809DDACAF96AF0FD78ED04B6A265E05AA257 password_expired: N password_last_changed: 2015-11-26 10:14:43 password_lifetime: NULL account_locked: N1 row in set (0.00 sec) 123456## 当前虚拟机2 MyServer2 #[root@MyServer2 bin]&gt; ./mysql -u burn_x509 -h 172.18.14.68 -P3307 -pEnter password: ERROR 1045 (28000): Access denied for user 'burn_x509'@'192.168.115.223' (using password: YES) # 即使默认开启了ssl，也是无法登录的 12345678910111213141516171819202122## 当前虚拟机1 MyServer#[root@MyServer data1]&gt; pwd/data1[root@MyServer data1]&gt; ll | grep pem-rw-------. 1 mysql mysql 1675 Nov 25 23:55 ca-key.pem-rw-r--r--. 1 mysql mysql 1070 Nov 25 23:55 ca.pem-rw-r--r--. 1 mysql mysql 1078 Nov 25 23:55 client-cert.pem-rw-------. 1 mysql mysql 1679 Nov 25 23:55 client-key.pem-rw-------. 1 mysql mysql 1675 Nov 25 23:55 private_key.pem-rw-r--r--. 1 mysql mysql 451 Nov 25 23:55 public_key.pem-rw-r--r--. 1 mysql mysql 1078 Nov 25 23:55 server-cert.pem-rw-------. 1 mysql mysql 1679 Nov 25 23:55 server-key.pem[root@MyServer data1]&gt; scp client-cert.pem client-key.pem root@172.18.14.41:~/The authenticity of host '172.18.14.41 (172.18.14.41)' can't be established.RSA key fingerprint is 5f:f5:3c:b0:57:79:8d:50:c6:c8:69:b0:90:6e:98:3b.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added '172.18.14.41' (RSA) to the list of known hosts.root@172.18.14.41's password: client-cert.pem 100% 1078 1.1KB/s 00:00 client-key.pem 100% 1679 1.6KB/s 00:00 1234567891011121314151617181920212223242526272829303132333435363738394041424344## 当前虚拟机2 MyServer2#[root@MyServer2 ~]&gt; ll | grep pem-rw-r--r--. 1 root root 1078 Nov 26 10:22 client-cert.pem-rw-------. 1 root root 1679 Nov 26 10:22 client-key.pem[root@MyServer2 ~]&gt; mysql -u burn_x509 -h 172.18.14.68 -P 3307 -p --ssl-cert=./client-cert.pem --ssl-key=./client-key.pem Enter password: Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 12Server version: 5.7.9-log MySQL Community Server (GPL)Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; \s--------------mysql Ver 14.14 Distrib 5.6.27, for linux-glibc2.5 (x86_64) using EditLine wrapperConnection id: 12Current database:Current user: burn_x509@192.168.115.223SSL: Cipher in use is DHE-RSA-AES256-SHA # 使用加密方式登录，且通过证书，因为这个用户 require X509Current pager: stdoutUsing outfile: ''Using delimiter: ;Server version: 5.7.9-log MySQL Community Server (GPL)Protocol version: 10Connection: 172.18.14.68 via TCP/IPServer characterset: utf8mb4Db characterset: utf8mb4Client characterset: utf8Conn. characterset: utf8TCP port: 3307Uptime: 32 min 15 secThreads: 2 Questions: 41 Slow queries: 0 Opens: 114 Flush tables: 1 Open tables: 107 Queries per second avg: 0.021--------------]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记（Day006：存储引擎二/多实例安装）]]></title>
    <url>%2F2018%2F05%2F30%2FMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(Day006)%2F</url>
    <content type="text"><![CDATA[MySQL学习笔记（Day006：存储引擎二/多实例安装）@(MySQL学习) [TOC] 一. MyISAM存储引擎(下)1. MyISAM还在使用的原因 历史原因，需要逐步替换 部分如User，DB等系统表(MyISAM引擎)，可以直接拷贝，比较方便 性能好，或者存储小不是MyISAM的优点，也不是存在的原因 2. MyISAM文件组成 frm 表结构文件 MYI 索引文件 MYD 数据文件 数据文件是堆表数据结构，堆是无序数据的集合 MYI中的叶子节点，指向MYD中的数据页 当数据移动到页外时，需要修改对应指针 3. myisamchkmyisamchk通过扫描MYD文件来重建MYI文件；如果MYD文件中某条记录有问题，将跳过该记录 二. Memory存储引擎1. Memory介绍 全内存存储的引擎 数据库重启后数据丢失 支持哈希索引 不支持事物 ###2. Memory特性 千万不要用Memory存储引擎去做缓存(Cache), 性能上不及Redis和Memcahced Memory不能禁用，当涉及内部排序操作的临时表时，使用该存储引擎 max_heap_table_size决定使用内存的大小，默认时16M 无论该表使用的什么引擎，只要使用到临时表，或者指定Memory，都受参数影响 当上面设置的内存放不下数据时，(&gt;=5.6)转为MyISAM,(&gt;=5.7)转为InnoDB 注意磁盘上临时路径空间的大小(tmpdir) 内存使用为会话(SESSION)级别，当心内核OOM 支持哈希索引，且仅支持等值查询 123456789101112131415161718192021222324252627mysql&gt; show global status like "%tmp%tables";+-------------------------+-------+| Variable_name | Value |+-------------------------+-------+| Created_tmp_disk_tables | 0 | -- 内存放不下，转成磁盘存储的数量,如果过大，考虑增大内存参数| Created_tmp_tables | 4 | -- 创建临时表的数量+-------------------------+-------+2 rows in set (0.00 sec)mysql&gt; show variables like 'tmpdir';+---------------+-------+| Variable_name | Value |+---------------+-------+| tmpdir | /tmp | -- memory转成磁盘存储的路径+---------------+-------+1 row in set (0.00 sec)mysql&gt; show create table User\G*************************** 1. row ***************************Table: UserCreate Table: CREATE TABLE `User` (`id` int(11) NOT NULL,`name` varchar(128) DEFAULT NULL,PRIMARY KEY (`id`),KEY `name` (`name`) USING HASH -- 对这个字段使用USING HASH,创建hash索引) ENGINE=MEMORY DEFAULT CHARSET=latin11 row in set (0.00 sec) 3. Memory的物理特性 内存不会一次性分配最大空间，而是随着使用逐步增到到最大值 通过链表管理空闲空间 使用固定长度存储数据 不支持BLOB和TEXT类型 可以创建自增主键 三. CSV存储引擎1. CSV介绍 CSV - Comma-Separated Values，使用逗号分隔 不支持特殊字符 CSV是一种标准文件格式 文件以纯文本形式存储表格数据 使用广泛 2. CSV文件组成 frm 表结构 CSV 数据文件 CSM 元数据信息 2. CSV特性 MySQL CSV存储引擎运行时，即创建CSV文件 通过MySQL标准接口来查看和修改CSV文件 无需将CSV文件导入到数据库，只需创建相同字段的表结构，拷贝CSV文件即可 CSV存储引擎表每个字段必须是NOT NULL属性 四.Federated存储引擎1. Federated介绍 允许本地访问远程MySQL数据库中表的数据 本地不存储任何数据文件 类似Oracle中的DBLink Federated存储引擎默认不开启, 需要在my.cnf的[mysqld]标签下添加 federated MySQL的Federated不支持异构数据库访问，MariaDB中的FederatedX支持 2. Federated 语法scheme://user_name[:password]@host_name[:port_num]/db_name/tbl_name CONNECTION=&#39;mysql://username:password@hostname:port/database/tablename&#39; 12345678---- 例子--CREATE TABLE `T1` (`A` VARCHAR(100),UNIQUE KEY (`A` (30))) ENGINE=FEDERATEDCONNECTION='MYSQL://david:123@127.0.0.1:3306/TEST/T1'; 五. 多实例安装1. 多实例介绍 一台服务器上安装多个MySQL数据库实例 可以充分利用服务器的硬件资源 通过mysqld_multi进行管理 2. 安装要求 MySQL实例1 - mysql1 port = 3306 datadir = /data1 socket = /tmp/mysql.sock1 MySQL实例2 - mysql2 port = 3307 datadir = /data2 socket = /tmp/mysql.sock2 MySQL实例3 - mysql3 port = 3308 datadir = /data3 socket = /tmp/mysql.sock3 MySQL实例4 - mysql4 port = 3309 datadir = /data4 socket = /tmp/mysql.sock4 该三个参数必须定制，且必须不同 (port / datadir / socket)server-id和多数据库实例没有关系，和数据库复制有关系。 3. 安装操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576## 多实例配置文件，可以mysqld_multi --example 查看例子#[root@MyServer /]&gt; cat /etc/my.cnf #[client] # 这个标签如果配置了用户和密码， # 并且[mysqld_multi]下没有配置用户名密码， # 则mysqld_multi stop时, 会使用这个密码 # 如果没有精确的匹配，则匹配[client]标签#user = root #password = 123#-------------[mysqld_multi]mysqld = /usr/local/mysql/bin/mysqld_safemysqladmin = /usr/local/mysql/bin/mysqladminuser = multi_adminpass = 123 # 官方文档中写的password，但是存在bug，需要改成pass(v5.7.9) # 写成password，start时正常，stop时，报如下错误 # Access denied for user 'multi_admin'@'localhost' (using password: YES)log = /var/log/mysqld_multi.log[mysqld1] # mysqld后面的数字为GNR, 是该实例的标识 # mysqld_multi start 1, mysqld_multi start 2-4server-id = 11socket = /tmp/mysql.sock1port = 3306bind_address = 0.0.0.0datadir = /data1user = mysqlperformance_schema = offinnodb_buffer_pool_size = 32Mskip_name_resolve = 1log_error = error.logpid-file = /data1/mysql.pid1[mysqld2]server-id = 12socket = /tmp/mysql.sock2port = 3307bind_address = 0.0.0.0datadir = /data2user = mysqlperformance_schema = offinnodb_buffer_pool_size = 32Mskip_name_resolve = 1log_error = error.logpid-file = /data2/mysql.pid2[mysqld3]server-id = 13socket = /tmp/mysql.sock3port = 3308bind_address = 0.0.0.0datadir = /data3user = mysqlperformance_schema = offinnodb_buffer_pool_size = 32Mskip_name_resolve = 1log_error = error.logpid-file = /data3/mysql.pid3[mysqld4]server-id = 14socket = /tmp/mysql.sock4port = 3309bind_address = 0.0.0.0datadir = /data4user = mysqlperformance_schema = offinnodb_buffer_pool_size = 32Mskip_name_resolve = 1log_error = error.logpid-file = /data4/mysql.pid4 12345678910111213141516171819## 准备好数据目录，并初始化安装#[root@MyServer ~]&gt; mkdir /data1[root@MyServer ~]&gt; mkdir /data2[root@MyServer ~]&gt; mkdir /data3[root@MyServer ~]&gt; mkdir /data4[root@MyServer ~]&gt; chown mysql.mysql /data&#123;1..4&#125;[root@MyServer ~]&gt; mysqld --initialize --user=mysql --datadir=/data1## 一些日志输出，并提示临时密码，下同#[root@MyServer ~]&gt; mysqld --initialize --user=mysql --datadir=/data2[root@MyServer ~]&gt; mysqld --initialize --user=mysql --datadir=/data3[root@MyServer ~]&gt; mysqld --initialize --user=mysql --datadir=/data4# 安装后，需要检查error.log 确保没有错误出现[root@MyServer ~]&gt; cp /usr/local/mysql/support-files/mysqld_multi.server /etc/init.d/mysqld_multid # 拷贝启动脚本，方便自启[root@MyServer ~]&gt; chkconfig mysqld_multid on 123456789101112131415161718192021[root@MyServer ~]&gt; mysqld_multi start[root@MyServer ~]&gt; mysqld_multi reportReporting MySQL serversMySQL server from group: mysqld1 is runningMySQL server from group: mysqld2 is runningMySQL server from group: mysqld3 is runningMySQL server from group: mysqld4 is running[root@MyServer ~]&gt; netstat -tunlp | grep mysql[root@MyServer ~]&gt; netstat -tunlp | grep mysqltcp 0 0 :::3307 :::* LISTEN 6221/mysqld tcp 0 0 :::3308 :::* LISTEN 6232/mysqld tcp 0 0 :::3309 :::* LISTEN 6238/mysqld tcp 0 0 :::3306 :::* LISTEN 6201/mysqld [root@MyServer ~]&gt; mysql -u root -S /tmp/mysql.sock1 -p -P3306## 使用-S /tmp/mysql.sock1 进行登录，并输入临时密码后，修改密码，下同#[root@MyServer ~]&gt; mysql -u root -S /tmp/mysql.sock2 -p -P3307[root@MyServer ~]&gt; mysql -u root -S /tmp/mysql.sock3 -p -P3308[root@MyServer ~]&gt; mysql -u root -S /tmp/mysql.sock4 -p -P3309 123456789101112131415161718192021222324252627282930313233343536373839---- mysql1--mysql&gt; show variables like "port"; +---------------+-------+| Variable_name | Value |+---------------+-------+| port | 3306 |+---------------+-------+1 row in set (0.00 sec)mysql&gt; show variables like "socket";+---------------+------------------+| Variable_name | Value |+---------------+------------------+| socket | /tmp/mysql.sock1 |+---------------+------------------+1 row in set (0.01 sec)mysql&gt; show variables like "datadir";+---------------+---------+| Variable_name | Value |+---------------+---------+| datadir | /data1/ |+---------------+---------+1 row in set (0.00 sec)---- 这样才能进行关闭数据库的操作-- 和[mysqld_multi]中的user，pass(注意在5.7.9中不是password)对应起来 （类比[client]标签）-- 一会测试federated链接，需要增加federated参数，并重启mysql2--mysql&gt; create user 'multi_admin'@'localhost' identified by '123';Query OK, 0 rows affected (0.00 sec)mysql&gt; grant shutdown on *.* to 'multi_admin'@'localhost';---- mysql2, mysql3, mysql4 类似。可以看到与my.cnf中对应的port和socket-- 六. Federated测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849---- mysql1 准备数据--mysql&gt; show variables like "port"; +---------------+-------+| Variable_name | Value |+---------------+-------+| port | 3306 | -- mysql1 实例端口+---------------+-------+1 row in set (0.00 sec)mysql&gt; create database burn;Query OK, 1 row affected (0.00 sec)mysql&gt; use burn;Database changedmysql&gt; create table book ( -&gt; id int not null auto_increment, -&gt; name varchar(128) not null, -&gt; primary key(id) -&gt; );Query OK, 0 rows affected (0.20 sec)mysql&gt; insert into book values(1, "book1");Query OK, 1 row affected (0.02 sec)mysql&gt; select * from book;+----+-------+| id | name |+----+-------+| 1 | book1 |+----+-------+1 row in set (0.00 sec)mysql&gt; create user 'burn'@'127.0.0.1' identified by '123';Query OK, 0 rows affected (0.00 sec)mysql&gt; grant select on burn.* to 'burn'@'127.0.0.1';Query OK, 0 rows affected (0.00 sec)mysql&gt; show grants for 'burn'@'127.0.0.1';+------------------------------------------------+| Grants for burn@127.0.0.1 |+------------------------------------------------+| GRANT USAGE ON *.* TO 'burn'@'127.0.0.1' || GRANT SELECT ON `burn`.* TO 'burn'@'127.0.0.1' |+------------------------------------------------+2 rows in set (0.00 sec) 1234567891011121314151617181920212223242526272829---- mysql2 测试Federated--mysql&gt; show variables like "port";+---------------+-------+| Variable_name | Value |+---------------+-------+| port | 3307 | -- msyql2 实例端口+---------------+-------+1 row in set (0.01 sec)mysql&gt; show engines;+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| Engine | Support | Comment | Transactions | XA | Savepoints |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| MyISAM | YES | MyISAM storage engine | NO | NO | NO || CSV | YES | CSV storage engine | NO | NO | NO || PERFORMANCE_SCHEMA | YES | Performance Schema | NO | NO | NO || BLACKHOLE | YES | /dev/null storage engine (anything you write to it disappears) | NO | NO | NO || MRG_MYISAM | YES | Collection of identical MyISAM tables | NO | NO | NO || InnoDB | DEFAULT | Supports transactions, row-level locking, and foreign keys | YES | YES | YES || ARCHIVE | YES | Archive storage engine | NO | NO | NO || MEMORY | YES | Hash based, stored in memory, useful for temporary tables | NO | NO | NO || FEDERATED | NO | Federated MySQL storage engine | NULL | NULL | NULL |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+---- federated 引擎没有打开--9 rows in set (0.00 sec) 1234567891011## 在[mysqld2]标签下面增加federated#[root@MyServer ~]&gt; cat /etc/my.cnf# ... 省略 ...[mysqld2]federated # 新增的配置项，表示打开federated引擎# ... 省略 ...[root@MyServer ~]&gt; mysqld_multi stop 2[root@MyServer ~]&gt; mysqld_multi start 2 # 重启配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152mysql&gt; show variables like "port";+---------------+-------+| Variable_name | Value |+---------------+-------+| port | 3307 | -- msyql2 实例端口+---------------+-------+1 row in set (0.01 sec)mysql&gt; show engines;+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| Engine | Support | Comment | Transactions | XA | Savepoints |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| MyISAM | YES | MyISAM storage engine | NO | NO | NO || CSV | YES | CSV storage engine | NO | NO | NO || PERFORMANCE_SCHEMA | YES | Performance Schema | NO | NO | NO || BLACKHOLE | YES | /dev/null storage engine (anything you write to it disappears) | NO | NO | NO || MRG_MYISAM | YES | Collection of identical MyISAM tables | NO | NO | NO || InnoDB | DEFAULT | Supports transactions, row-level locking, and foreign keys | YES | YES | YES || ARCHIVE | YES | Archive storage engine | NO | NO | NO || MEMORY | YES | Hash based, stored in memory, useful for temporary tables | NO | NO | NO || FEDERATED | YES | Federated MySQL storage engine | NO | NO | NO |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+9 rows in set (0.00 sec)---- 显示 federated 已经启用--mysql&gt; create database federated_test;Query OK, 1 row affected (0.00 sec)mysql&gt; use federated_test;Database changedmysql&gt; create table federated_table_1 ( -&gt; id int not null auto_increment, -&gt; name varchar(128) not null, -&gt; primary key(id) -&gt; ) engine=federated -&gt; connection='mysql://burn:123@127.0.0.1:3306/burn/book';Query OK, 0 rows affected (0.04 sec)mysql&gt; select * from federated_table_1;+----+-------+| id | name |+----+-------+| 1 | book1 | -- 和 mysqld1 上的内容一致。+----+-------+1 row in set (0.00 sec)---- 由于只有select权限，无法对该表进行insert操作--mysql&gt; insert into federated_table_1 values(2, "book2");ERROR 1296 (HY000): Got error 10000 'Error on remote system: 1142: INSERT command denied to user 'burn'@'127.0.0.1' for table 'book'' from FEDERATED]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记（Day005：slow_log/generic_log/audit/存储引擎一）]]></title>
    <url>%2F2018%2F05%2F30%2FMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(Day005)%2F</url>
    <content type="text"><![CDATA[MySQL学习笔记（Day005：slow_log/generic_log/audit/存储引擎一）@(MySQL学习) [TOC] 一. 慢查询日志进阶1. 相关参数： slow_query_log 是否开启慢查询日志 slow_query_log_file 慢查询日志文件名, 在my.cnf我们已经定义为slow.log，默认是 机器名-slow.log long_query_time 制定慢查询阈值, 单位是秒，且当版本 &gt;=5.5.X，支持毫秒。例如0.5即为500ms 大于该值，不包括值本身。例如该值为2，则执行时间正好等于2的SQL语句不会记录 log_queries_not_using_indexes 将没有使用索引的SQL记录到慢查询日志 如果一开始因为数据少，查表快，耗时的SQL语句没被记录，当数据量大时，该SQL可能会执行很长时间 需要测试阶段就要发现问题，减小上线后出现问题的概率 log_throttle_queries_not_using_indexes 限制每分钟内，在慢查询日志中，去记录没有使用索引的SQL语句的次数；版本需要&gt;=5.6.X 因为没有使用索引的SQL可能会短时间重复执行，为了避免日志快速增大，限制每分钟的记录次数 min_examined_row_limit 扫描记录少于改值的SQL不记录到慢查询日志 结合去记录没有使用索引的SQL语句的例子，有可能存在某一个表，数据量维持在百行左右，且没有建立索引。这种表即使不建立索引，查询也很快，扫描记录很小，如果确定有这种表，则可以通过此参数设置，将这个SQL不记录到慢查询日志。 log_slow_admin_statements 记录超时的管理操作SQL到慢查询日志，比如ALTER/ANALYZE TABLE log_output 慢查询日志的格式，[FILE | TABLE | NONE]，默认是FILE；版本&gt;=5.5 如果设置为TABLE，则记录的到mysql.slow_log log_slow_slave_statements 在从服务器上开启慢查询日志 log_timestamps 写入时区信息。可根据需求记录UTC时间或者服务器本地系统时间 2. 慢查询日志实践 设置慢查询记录的相关参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647---- 终端A---- 注意做实验以前，先把my.cnf中的 slow_query_log = 0, 同时将min_examined_row_limit = 100 进行注释--mysql&gt; select version();+-----------+| version() |+-----------+| 5.7.9-log |+-----------+1 row in set (0.01 sec)mysql&gt; show variables like "slow_query_log"； -- 为了测试，特地在my.cnf中关闭了该选项+----------------+-------+| Variable_name | Value |+----------------+-------+| slow_query_log | OFF |+----------------+-------+1 row in set (0.00 sec)mysql&gt; set global slow_query_log = 1; -- slow_query_log可以在线打开Query OK, 0 rows affected (0.00 sec)mysql&gt; show variables like "slow_query_log"; -- 已经打开+----------------+-------+| Variable_name | Value |+----------------+-------+| slow_query_log | ON |+----------------+-------+1 row in set (0.00 sec)mysql&gt; show variables like "long_query_time";+-----------------+----------+| Variable_name | Value |+-----------------+----------+| long_query_time | 2.000000 | -- my.cnf 中该值设置为2秒+-----------------+----------+1 row in set (0.00 sec)mysql&gt; show variables like "min_ex%"; -- my.cnf 中已经关闭注释，所以这里为0+------------------------+-------+| Variable_name | Value |+------------------------+-------+| min_examined_row_limit | 0 |+------------------------+-------+1 row in set (0.00 sec) 查看慢查询日志 1234567##终端B#[root@localhost mysql_data]# tail -f slow.log /usr/local/mysql/bin/mysqld, Version: 5.7.9-log (MySQL Community Server (GPL)). started with:Tcp port: 3306 Unix socket: (null)Time Id Command Argument #测试没有任何慢查询日志信息 进行模拟耗时操作 12345678910---- 终端A--mysql&gt; select sleep(4);+----------+| sleep(4) |+----------+| 0 |+----------+1 row in set (4.00 sec) 最终产生慢查询日志 123456789101112131415##终端B#[root@localhost mysql_data]# tail -f slow.log /usr/local/mysql/bin/mysqld, Version: 5.7.9-log (MySQL Community Server (GPL)). started with:Tcp port: 3306 Unix socket: (null)Time Id Command Argument #测试没有任何慢查询日志信息# Time: 2015-11-21T07:18:10.741663+08:00# User@Host: root[root] @ localhost [] Id: 2# Query_time: 4.000333 Lock_time: 0.000000 Rows_sent: 1 Rows_examined: 0 #这个就是min_examined_row_limit #设置的意义。如my.cnf中设置该值为100 #则这条语句因为Rows_examined &lt; 100,而不会被记录SET timestamp=1448061490;select sleep(4); 注意如果在终端A中set global min_examined_row_limit = 100;, 然后执行select sleep(5);，会发现该记录仍然被记录到慢查询日志中。原因是因为set global min_examined_row_limit设置的是全局变量，此次会话不生效。 但是我们上面set global slow_query_log = 1；却是在线生效的，这点有所不通 mysqldumpslow1234567891011121314151617181920212223242526272829303132333435363738394041424344454647[root@localhost mysql_data]# mysqldumpslow slow.logReading mysql slow query log from slow.logCount: 2 Time=0.00s (0s) Lock=0.00s (0s) Rows=0.0 (0), 0users@0hosts Time: N-N-21T07:N:N.N+N:N # User@Host: root[root] @ localhost [] Id: N # Query_time: N.N Lock_time: N.N Rows_sent: N Rows_examined: N SET timestamp=N; select sleep(N)Count: 1 Time=0.00s (0s) Lock=0.00s (0s) Rows=0.0 (0), 0users@0hosts # Time: N-N-21T07:N:N.N+N:N # User@Host: root[root] @ localhost [] Id: N # Query_time: N.N Lock_time: N.N Rows_sent: N Rows_examined: N SET timestamp=N; select sleep(N) #######################################################################[root@localhost mysql_data]# mysqldumpslow --helpUsage: mysqldumpslow [ OPTS... ] [ LOGS... ]Parse and summarize the MySQL slow query log. Options are --verbose verbose --debug debug --help write this text to standard output -v verbose -d debug -s ORDER what to sort by (al, at, ar, c, l, r, t), 'at' is default #根据以下某个信息来排序 al: average lock time ar: average rows sent at: average query time c: count l: lock time r: rows sent t: query time -r reverse the sort order (largest last instead of first) # 逆序输出 -t NUM just show the top n queries # TOP(n)参数 -a don't abstract all numbers to N and strings to 'S' -n NUM abstract numbers with at least n digits within names -g PATTERN grep: only consider stmts that include this string -h HOSTNAME hostname of db server for *-slow.log filename (can be wildcard), default is '*', i.e. match all -i NAME name of server instance (if using mysql.server startup script) -l don't subtract lock time from total time 如果在线上操作，不需要mysqldumpslow去扫整个slow.log， 可以去tail -n 10000 slow.log &gt; last_10000_slow.log(10000这个数字根据实际情况进行调整),然后进行mysqldumpslow last_10000_slow.log 慢查询日志存入表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354---- 在my.cnf 中增加 log_output = TABLE，打开slow_query_log选项，然后重启数据库实例--mysql&gt; show variables like "log_output%";+---------------+-------+| Variable_name | Value |+---------------+-------+| log_output | TABLE |+---------------+-------+1 row in set (0.00 sec)mysql&gt; show variables like "slow_query_log";+----------------+-------+| Variable_name | Value |+----------------+-------+| slow_query_log | ON |+----------------+-------+1 row in set (0.00 sec)mysql&gt; select * from mysql.slow_log;+----------------------------+---------------------------+-----------------+-----------------+-----------+---------------+----+----------------+-----------+-----------+-----------------+-----------+| start_time | user_host | query_time | lock_time | rows_sent | rows_examined | db | last_insert_id | insert_id | server_id | sql_text | thread_id |+----------------------------+---------------------------+-----------------+-----------------+-----------+---------------+----+----------------+-----------+-----------+-----------------+-----------+| 2015-11-20 19:50:28.574677 | root[root] @ localhost [] | 00:00:04.000306 | 00:00:00.000000 | 1 | 0 | | 0 | 0 | 11 | select sleep(4) | 3 |+----------------------------+---------------------------+-----------------+-----------------+-----------+---------------+----+----------------+-----------+-----------+-----------------+-----------+1 row in set (0.00 sec)mysql&gt; show create table mysql.slow_log;---- 表结构输出省略-- 关键一句如下：--ENGINE=CSV DEFAULT CHARSET=utf8 COMMENT='Slow log' -- ENGINE=CSV 这里使用的是CSV的引擎,性能较差-- 建议将slow_log表的存储引擎改成MyISAMmysql&gt; alter table mysql.slow_log engine = myisam;ERROR 1580 (HY000): You cannot 'ALTER' a log table if logging is enabled '-- 提示我正在记录日志中，不能转换mysql&gt; set global slow_query_log = 0; -- 先停止记录日志Query OK, 0 rows affected (0.01 sec)mysql&gt; alter table mysql.slow_log engine = myisam; -- 然后转换表的引擎Query OK, 2 rows affected (5.05 sec)Records: 2 Duplicates: 0 Warnings: 0mysql&gt; set global slow_query_log = 1; -- 再开启记录日志Query OK, 0 rows affected (0.00 sec)mysql&gt; show create table mysql.slow_log;---- 表结构输出省略-- 关键一句如下：--ENGINE=MyISAM DEFAULT CHARSET=utf8 COMMENT='Slow log' -- ENGINE 变成了MyISAM 使用TABLE的优势在于方便查询，但是记住当在备份的时候，不要备份慢查询日志的表，避免备份过大。使用FILE也可以，需要定时清除该文件，避免单文件过大。 二. 通用日志(generic_log)与审计###1. 通用日志作用 当需要查找某条特定SQL语句，且该SQL语句执行较快，无法记录到slow_log中时，可以开启通用日志generic_log,进行全面记录， 可用于审计Audit 通用日志会记录所有操作，性能下降明显。所以如果需要审计，需要Audit Plugin ###2. 审计插件 MariaDB Audit 插件 MySQL社区版本目前没有提供Audit的功能，企业版本提供了该功能。MariaDB 提供了开源的Audit插件，且MySQL也能使用。 插件下载 server_audit-1.2.0.tar.gz 上述链接如果失效，可以进入官方页面注册，然后下载 官方注册下载插件 ###3. Audit Plugin安装 MySQL5.7.9 审计插件安装失败，提示如下： ERROR 1126 (HY000): Can&#39;t open shared library &#39;/usr/lib64/mysql/plugin/server_audit.so&#39; (errno: 13 /usr/lib64/mysql/plugin/server_audit.so: undefined symbol: _my_thread_var) MySQL5.6.27 审计插件安装成功，步骤如下： 123456789101112131415161718192021222324252627# 找到plugin位置[root@localhost ~]&gt; cat /etc/my.cnf | grep plugin_dirplugin_dir=/usr/local/mysql/lib/plugin# 解压plugin[root@localhost ~]&gt; tar zxvf server_audit-1.2.0.tar.gzserver_audit-1.2.0/server_audit-1.2.0/linux-32_debug/server_audit-1.2.0/linux-32_debug/server_audit.soserver_audit-1.2.0/linux-32/server_audit-1.2.0/linux-32/server_audit.soserver_audit-1.2.0/linux-64_debug/server_audit-1.2.0/linux-64_debug/server_audit.soserver_audit-1.2.0/windows-32/server_audit-1.2.0/windows-32/server_audit.dllserver_audit-1.2.0/windows-64_debug/server_audit-1.2.0/windows-64_debug/server_audit.dllserver_audit-1.2.0/linux-64/server_audit-1.2.0/linux-64/server_audit.soserver_audit-1.2.0/windows-64/server_audit-1.2.0/windows-64/server_audit.dllserver_audit-1.2.0/windows-32_debug/server_audit-1.2.0/windows-32_debug/server_audit.dll# 移动插件到对应的插件目录[root@localhost ~]&gt; mv server_audit-1.2.0/linux-64/server_audit.so /usr/local/mysql/lib/plugin[root@localhost ~]&gt; cd /usr/local/mysql/lib/plugin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556---- 相关安装步骤--mysql&gt; select version();+------------+| version() |+------------+| 5.6.27-log |+------------+1 row in set (0.00 sec)mysql&gt; INSTALL PLUGIN server_audit SONAME 'server_audit.so'; -- 安装插件，该步骤在5.7.9中失败Query OK, 0 rows affected (0.00 sec)mysql&gt; show variables like "%server_audit%"; -- 查看和server_audit相关的参数+-------------------------------+-----------------------+| Variable_name | Value |+-------------------------------+-----------------------+| server_audit_events | || server_audit_excl_users | || server_audit_file_path | server_audit.log || server_audit_file_rotate_now | OFF || server_audit_file_rotate_size | 1000000 || server_audit_file_rotations | 9 || server_audit_incl_users | || server_audit_logging | OFF || server_audit_mode | 1 || server_audit_output_type | file || server_audit_syslog_facility | LOG_USER || server_audit_syslog_ident | mysql-server_auditing || server_audit_syslog_info | || server_audit_syslog_priority | LOG_INFO |+-------------------------------+-----------------------+14 rows in set (0.00 sec)mysql&gt; set global server_audit_logging = 1; -- 打开审计功能Query OK, 0 rows affected (0.00 sec)mysql&gt; show variables like "server_audit_logging"; +----------------------+-------+| Variable_name | Value |+----------------------+-------+| server_audit_logging | ON |+----------------------+-------+1 row in set (0.00 sec)mysql&gt; show status like '%audit%';+----------------------------+------------------+| Variable_name | Value |+----------------------------+------------------+| server_audit_active | ON || server_audit_current_log | server_audit.log || server_audit_last_error | || server_audit_writes_failed | 0 |+----------------------------+------------------+4 rows in set (0.00 sec) 1234567##查看审计日志#[root@MyServer mysql_data]&gt; tail -f server_audit.log 20151120 22:40:54,MyServer,root,localhost,2,9,QUERY,,'set global server_audit_logging = 1',020151120 22:41:16,MyServer,root,localhost,2,10,QUERY,,'show variables like "server_audit_logging"',020151120 22:41:53,MyServer,root,localhost,1,5,QUERY,,'show status like \'%audit%\'',0 以上仅为基本功能操作，详细的细粒度控制请参考官方文档 三. 存储引擎(一)1.Mysql上支持的存储引擎123456789101112131415mysql&gt; show engines;+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| Engine | Support | Comment | Transactions | XA | Savepoints |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| MyISAM | YES | MyISAM storage engine | NO | NO | NO || CSV | YES | CSV storage engine | NO | NO | NO || PERFORMANCE_SCHEMA | YES | Performance Schema | NO | NO | NO || BLACKHOLE | YES | /dev/null storage engine (anything you write to it disappears) | NO | NO | NO || MRG_MYISAM | YES | Collection of identical MyISAM tables | NO | NO | NO || InnoDB | DEFAULT | Supports transactions, row-level locking, and foreign keys | YES | YES | YES || ARCHIVE | YES | Archive storage engine | NO | NO | NO || MEMORY | YES | Hash based, stored in memory, useful for temporary tables | NO | NO | NO || FEDERATED | NO | Federated MySQL storage engine | NULL | NULL | NULL |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+9 rows in set (0.00 sec) 2. 存储引擎的概念 用来处理数据库的相关CRUD操作 每个数据库都有存储引擎，只是MySQL比较强调存储引擎的概念。 3. MySQL存储引擎 官方存储引擎 MyISAM InnoDB – 推荐；其他引擎已经体停止维护和开发 Memory Federated CSV Archive 第三方存储引擎 TokuDB – 开源，适合插入密集型 InfoBright – 商业，开源版本有数据量限制。属于列存储，面向OLAP场景 Spider 第三方存储引擎在特定场合下比较适合，除此之外，都应该使用InnoDB 3. 存储引擎之MyISAM MySQL5.1版本之前的默认存储引擎 堆表数据结构 表锁设计 支持数据静态压缩 不支持事物 数据容易丢失 索引容易损坏 唯一优点 数据文件可以直接拷贝到另一台服务器使用 现在MySQL中还有用MyISAM的表，主要是历史原因。数据库文件以MY开头的基本都是MyISAM的表]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记（Day004：权限拾遗/Role模拟/Workbench/体系结构）]]></title>
    <url>%2F2018%2F05%2F30%2FMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(Day004)%2F</url>
    <content type="text"><![CDATA[MySQL学习笔记（Day004：权限拾遗/Role模拟/Workbench/体系结构）@(MySQL学习) [TOC] ##一. 权限拾遗 1. GRANT与创建用户123456mysql&gt; grant select on sys.* to 'perf'@'127.0.0.1' identified by '123';Query OK, 0 rows affected, 1 warning (0.01 sec) -- 这里有一个warningmysql&gt; show warnings;-- 输入warning的Message如下：-- Using GRANT for creating new user is deprecated and will be removed in future release. Create new user with CREATE USER statement. 上面的这个例子使用GRANT赋权限的同时创建了&#39;perf&#39;@&#39;127.0.0.1&#39;这个用户，但是出现了warning，从给出的提示看来，以后的MySQL版本会废弃掉这种方式 正确的创建用户并赋权的方式1234mysql&gt; create user 'pref'@'127.0.0.1' identified by '123';Query OK, 0 rows affected (0.00sec)mysql&gt; grant select on sys.* to 'perf'@'127.0.0.1';Query OK, 0 rows affected (0.00sec) 2. 查看某一个用户的权限12345678mysql&gt; show grants for 'perf'@'127.0.0.1'; +-----------------------------------------------+| Grants for perf@127.0.0.1 |+-----------------------------------------------+| GRANT USAGE ON *.* TO 'perf'@'127.0.0.1' | -- USAGE表示用户可以登录| GRANT SELECT ON `sys`.* TO 'perf'@'127.0.0.1' | -- 对sys库的所有表有select权限+-----------------------------------------------+2 rows in set (0.00 sec) 3. 删除某一个用户12mysql&gt; drop user 'perf'@'127.0.0.1';Query OK, 0 rows affected (0.00sec) 4. MySQL权限信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576mysql&gt; select * from mysql.user where user='perf'\G*************************** 1. row *************************** Host: 127.0.0.1 User: perf Select_priv: N ---由于perf用户是对sys库有权限，所以这里（USER）全是N Insert_priv: N Update_priv: N Delete_priv: N Create_priv: N Drop_priv: N Reload_priv: N Shutdown_priv: N Process_priv: N File_priv: N Grant_priv: N References_priv: N Index_priv: N Alter_priv: N Show_db_priv: N Super_priv: N Create_tmp_table_priv: N Lock_tables_priv: N Execute_priv: N Repl_slave_priv: N Repl_client_priv: N Create_view_priv: N Show_view_priv: N Create_routine_priv: N Alter_routine_priv: N Create_user_priv: N Event_priv: N Trigger_priv: NCreate_tablespace_priv: N ssl_type: ssl_cipher: x509_issuer: x509_subject: max_questions: 0 max_updates: 0 max_connections: 0 max_user_connections: 0 plugin: mysql_native_password authentication_string: *23AE809DDACAF96AF0FD78ED04B6A265E05AA257 password_expired: N password_last_changed: 2015-11-18 12:20:13 password_lifetime: NULL account_locked: N -- 如果这里为Y，该用户就无法使用了1 row in set (0.00 sec)------------------------我是分割线-----------------------------mysql&gt; select * from mysql.db where user='perf'\G *************************** 1. row *************************** Host: 127.0.0.1 Db: sys -- sys 数据库 User: perf Select_priv: Y -- 有select权限，和我们赋予perf的权限一致 Insert_priv: N Update_priv: N Delete_priv: N Create_priv: N Drop_priv: N Grant_priv: N References_priv: N Index_priv: N Alter_priv: NCreate_tmp_table_priv: N Lock_tables_priv: N Create_view_priv: N Show_view_priv: N Create_routine_priv: N Alter_routine_priv: N Execute_priv: N Event_priv: N Trigger_priv: N1 row in set (0.00 sec) 注意：不建议使用INSERT或者GRANT对元数据表进行修改，来达到修改权限的目的 5. information_schema123456789101112131415161718192021222324mysql&gt; select user();+----------------+| user() |+----------------+| perf@127.0.0.1 |+----------------+1 row in set (0.00 sec)mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema | -- 这是一个特殊的数据库，我们虽然可以看见，但其实没有权限| sys |+--------------------+2 rows in set (0.00 sec)mysql&gt; use information_schema;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; select * from INNODB_CMP;ERROR 1227 (42000): Access denied; you need (at least one of) the PROCESS privilege(s) for this operation 二. MySQL模拟角色1. 角色的定义： 角色(Role)可以用来批量管理用户，同一个角色下的用户，拥有相同的权限。MySQL5.7.X以后可以模拟角色(Role)的功能，通过mysql.proxies_priv模拟实现。mysql.proxies_priv在5.5.X和5.6.X的时候就存在，但是无法模拟角色(Role)功能。 2. 模拟角色操作：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130-- 感谢 @M062 郭释 同学 对这里提出的修正-- 查看当前proxy是否代开mysql&gt; show variables like "%proxy%";+-----------------------------------+-------+| Variable_name | Value |+-----------------------------------+-------+| check_proxy_users | OFF || mysql_native_password_proxy_users | OFF || proxy_user | || sha256_password_proxy_users | OFF |+-----------------------------------+-------+4 rows in set (0.00 sec)mysql&gt; set global check_proxy_users=ON;Query OK, 0 rows affected (0.00 sec)mysql&gt; set global mysql_native_password_proxy_users=ON;Query OK, 0 rows affected (0.00 sec)mysql&gt; exit; -- 以上设置参数，对当前会话无效，需要退出后重新登录 -- 如果有需要，可以设置到my.cnf中去mysql&gt; show variables like "%proxy%";+-----------------------------------+-------+| Variable_name | Value |+-----------------------------------+-------+| check_proxy_users | ON || mysql_native_password_proxy_users | ON || proxy_user | || sha256_password_proxy_users | OFF |+-----------------------------------+-------+4 rows in set (0.00 sec)-- ---------------至此，下面的权限映射才有意义---------------mysql&gt; create user 'junior_dba'@'127.0.0.1'; -- 相当于定于一个 角色(Role),省略密码，仅为演示 -- 但这只是个普通的用户，名字比较有(Role)的感觉 -- 有点类似用户组Query OK, 0 rows affected (0.00sec)mysql&gt; create user 'tom'@'127.0.0.1'; -- 用户1，省略密码，仅为演示Query OK, 0 rows affected (0.02sec)mysql&gt; create user 'jim'@'127.0.0.1'; -- 用户2，省略密码，仅为演示Query OK, 0 rows affected (0.02sec)mysql&gt; grant proxy on 'junior_dba'@'127.0.0.1' to 'tom'@'127.0.0.1'; -- 将junior_dba的权限映射(map)到tomQuery OK, 0 rows affected (0.02sec)mysql&gt; grant proxy on 'junior_dba'@'127.0.0.1' to 'jim'@'127.0.0.1'; -- 然后映射(map)给jimQuery OK, 0 rows affected (0.01sec)mysql&gt; grant select on *.* to 'junior_dba'@'127.0.0.1'; -- 给junior_dba（模拟的Role）赋予实际权限Query OK, 0 rows affected (0.01 sec)mysql&gt; show grants for 'junior_dba'@'127.0.0.1'; -- 查看 junior_dba的权限+-------------------------------------------------+| Grants for junior_dba@127.0.0.1 |+-------------------------------------------------+| GRANT SELECT ON *.* TO 'junior_dba'@'127.0.0.1' |+-------------------------------------------------+1 row in set (0.00 sec)mysql&gt; show grants for 'jim'@'127.0.0.1'; -- 查看jim的权限+--------------------------------------------------------------+| Grants for jim@127.0.0.1 |+--------------------------------------------------------------+| GRANT USAGE ON *.* TO 'jim'@'127.0.0.1' || GRANT PROXY ON 'junior_dba'@'127.0.0.1' TO 'jim'@'127.0.0.1' |+--------------------------------------------------------------+2 rows in set (0.00 sec)mysql&gt; show grants for 'tom'@'127.0.0.1'; -- 查看tom的权限 +--------------------------------------------------------------+| Grants for tom@127.0.0.1 |+--------------------------------------------------------------+| GRANT USAGE ON *.* TO 'tom'@'127.0.0.1' || GRANT PROXY ON 'junior_dba'@'127.0.0.1' TO 'tom'@'127.0.0.1' |+--------------------------------------------------------------+2 rows in set (0.00 sec)mysql&gt; select * from mysql.proxies_priv; -- 查看 proxies_priv的权限+-----------+------+--------------+--------------+------------+----------------------+---------------------+| Host | User | Proxied_host | Proxied_user | With_grant | Grantor | Timestamp |+-----------+------+--------------+--------------+------------+----------------------+---------------------+| localhost | root | | | 1 | boot@connecting host | 0000-00-00 00:00:00 || 127.0.0.1 | tom | 127.0.0.1 | junior_dba | 0 | root@localhost | 0000-00-00 00:00:00 || 127.0.0.1 | jim | 127.0.0.1 | junior_dba | 0 | root@localhost | 0000-00-00 00:00:00 |+-----------+------+--------------+--------------+------------+----------------------+---------------------+3 rows in set (0.00 sec)-- 测试jim的权限-- 如果不按照@M062 郭释同学给出的修正，-- 即便映射了junior_dba的select权限，但是jim仍然无法select-- 甚至show databases; 都无法得到所有数据库信息。mysql&gt; select user();+---------------+| user() |+---------------+| jim@127.0.0.1 |+---------------+1 row in set (0.00 sec)mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+4 rows in set (0.00 sec)mysql&gt; select host,user from mysql.user;+-----------+------------+| host | user |+-----------+------------+| 127.0.0.1 | jim || 127.0.0.1 | junior_dba || 127.0.0.1 | perf || 127.0.0.1 | tom || localhost | mysql.sys || localhost | root |+-----------+------------+6 rows in set (0.00 sec)mysql&gt; create database aaa;ERROR 1044 (42000): Access denied for user 'junior_dba'@'127.0.0.1' to database 'aaa' mysql.proxies_priv仅仅是对Role的模拟，和Oracle的角色还是有所不同.官方称呼为Role like MySQL5.6.X 模拟Role功能需要安装插件，具体方法请参考论坛帖子 官方文档1 官方文档2 三. Workbench与Utilities介绍1. 下载 Workbench-win32下载 Workbench-win64下载 Utilities下载 2. Workbench功能概述 SQL语句格式化 SQL关键字upcase MySQL Dashboard SQL语法提示 ER图 Forward Engine //ER图 --&gt; DB表结构 Reverse //DB表结构 --&gt; ER图 3. Utilities安装1shell&gt; python setup.py install # 如果安装不成功，查看一下python的版本。推荐2.7.X 四. MySQL体系结构1. 数据库 数据库（数据库文件）是一个或者一组二进制文件，通常来说存在与文件系统之上。 2. 数据库实例 由数据库后台进程/线程以及一个共享区域组成(程序的概念),数据库实例是用来操作数据库文件的 注意：MySQL中，数据库实例和数据库是一一对应的。没有Oracle的一对多(RAC)的机制。 3. MySQL体系结构 单进程多线程结构 不会影响MySQL的性能，看程序如何写。（多进程程序，进程间通信开销大于多线程） 存储引擎的概念 可以理解成文件系统，例如FAT32, NTFS, EXT4。 一个表是一个分区，引擎就是分区的文件系统 存储引擎的对象就是表 show tables; 可以看到每个表对应的是上面引擎(Engine) 除了特殊情况，我们现在就只考虑INNODB 体系结构图 逻辑存储结构 |MySQL逻辑存储结构| |:—————:| |instance| |database| |schema| |table| |view| 一个DB对应一个schema 一个DB对应一个文件夹 一个表对应一组文件 123 |--&gt; table1 --- | view1 |MySQL Instance -----&gt; Database ----&gt; Schema ---&gt; |--&gt; table2 --- | view2 | |--&gt; table3 --- | View3 | 注意：MySQL中一个Database对应一个Schema,之所以要有这个schema, 是为了兼容其他数据库information_schema数据库不是文件夹，存在于内存中，在启动时创建 4. MySQL物理存储结构 MySQL配置文件 datadir- 存储数据二进制文件的路径 表结构的组成 frm：表结构定义文件 MYI：索引文件 MYD：数据文件 可以用hexdump -c XXX.frm查看二进制文件(意义不大) show create table tablename; mysqlfrm (utilities工具包) 1shell&gt; mysqlfrm --diagnostic /data/mysql_data/aaa/.a.frm #可将frm文件转成create table的语句 错误日志文件 log_err- 建议配置成统一的名字 方便定位错误 慢查询日志文件 将运行超过某一个时间阈(yu四声)值的SQL语句记录到文件- MySQL &lt; 5.1 ：以秒为单位 - MySQL &gt;= 5.1 : 以毫秒为单位 - MySQL &gt;= 5.5 : 可以将慢查询日志记录到表 - MySQL &gt;= 5.6 : 以更细的粒度记录慢查询 - MySQL &gt;= 5.7 : 增加timestamps支持 slow_query_log_file- 建议配置成统一的名字 用于优化查询]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记（Day003：升级/参数/连接/权限）]]></title>
    <url>%2F2018%2F05%2F30%2FMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(Day003)%2F</url>
    <content type="text"><![CDATA[MySQL学习笔记（Day003：升级/参数/连接/权限）@(MySQL学习) [TOC] 一. 数据库升级###1. 环境说明：一般说来，MySQL数据库的二进制数据文件，也就是my.cnf中的配置项datadir所在的位置，和我们MySQL应用程序安装的位置，是分开的，仅仅通过配置项告诉MySQL，数据库的数据存在datadir这个目录下。当程序和数据分离以后，方便我们对数据库应用程序做版本的升级或者回退。 ###2. 环境举例： MySQL安装目录： MySQL 5.6.27: /usr/local/mysql-5.6.27-linux-glibc2.5-x86_64 MySQL 5.7.9 : /usr/local/mysql-5.7.9-linux-glibc2.5-x86_64 datadir目录： /data/mysq_data/ 初始环境： 12345678910111213141516shell&gt; ll | grep mysqllrwxrwxrwx 1 root root 34 Nov 16 13:40 mysql -&gt; mysql-5.6.27-linux-glibc2.5-x86_64drwxr-xr-x 13 root mysql 4096 Nov 16 13:37 mysql-5.6.27-linux-glibc2.5-x86_64drwxr-xr-x 9 7161 wheel 4096 Oct 12 00:29 mysql-5.7.9-linux-glibc2.5-x86_64shell&gt; ll /data/mysql_data/total 13540-rw-rw---- 1 mysql mysql 65468 Nov 16 13:50 bin.000001-rw-rw---- 1 mysql mysql 1176237 Nov 16 13:50 bin.000002-rw-rw---- 1 mysql mysql 26 Nov 16 13:50 bin.index-rw-rw---- 1 mysql mysql 6882 Nov 16 13:50 error.log-rw-rw---- 1 mysql mysql 865 Nov 16 13:50 ib_buffer_pool-rw-rw---- 1 mysql mysql 12582912 Nov 16 13:50 ibdata1drwx------ 2 mysql mysql 4096 Nov 16 13:50 mysqldrwx------ 2 mysql mysql 4096 Nov 16 13:50 performance_schemadrwx------ 2 mysql mysql 4096 Nov 16 13:49 test 3. 版本升级12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667shell&gt; /etc/init.d/mysqld stop #安全的停止数据库的运行shell&gt; cd /usr/local/shell&gt; unlink mysqlshell&gt; ln -s mysql-5.7.9-linux-glibc2.5-x86_64 mysql #此时，MySQL的应用程序版本已经升级完成 #/etc/init.d/mysqld #/etc/profile中PATH增加的/usr/local/mysql/bin #都不需要做任何的改变，即可将当前系统的mysql版本升级完成 #注意：此时只是应用程序升级完成，系统表仍然还是5.6的版本 shell&gt; cd /usr/local/mysqlshell&gt; chown root.mysql . -R#5.7.x -&gt; 5.6.X 降级存在问题，这里暂且注释掉#shell&gt; cp /data/mysql_data/mysql /你的备份路径/mysql_5_6_27.backup -r #该步骤将mysql5.6.27版本的系统表进行了备份，以便将来可以回退 shell&gt; /etc/init.d/mysqld start #此时 /etc/init.d/mysqld start # 可以启动# 且可以使用 mysql -u root -p （原密码） 进入数据库# show databases;存在test表，而没有sys表（数据的二进制文件兼容）# 但是如果去看error.log会发现好多的WARNNING# 所以，这个时候我们要去 upgrade 去升级 shell&gt; mysql_upgrade -p -s #参数 -s 一定要加,表示只更新系统表，-s: upgrade-system-tables #如果不加-s,则会把所有库的表以5.7.9的方式重建，线上千万别这样操作 #因为数据库二进制文件是兼容的，无需升级 #什么时候不需要-s ? 当一些老的版本的存储格式需要新的特性， # 来提升性能时，不加-s #即使通过slave进行升级，也推荐使用该方式升级，速度比较快 Enter password: The --upgrade-system-tables option was used, databases wont be touched.Checking if update is needed.Checking server version.Running queries to upgrade MySQL server.Upgrading the sys schema.Upgrade process completed successfully.Checking if update is needed. shell&gt; mysql -u root -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 4Server version: 5.7.9-log MySQL Community Server (GPL)Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql | # 这个就是升级后的系统库，如果回退，将备份的拷贝回来覆盖即可| performance_schema || sys | # 5.7 新的sys库| test | # 5.6 中的test库+--------------------+5 rows in set (0.00 sec) 5.1.X、5.5.X 、5.6.X 是可以直接通过该方式升级到5.7.X。5.0.X未知，需要测试 注意：如果原来数据二进制文件保存在/usr/local/mysql-5.6.27-linux-glibc2.5-x86_64/data目录下,在升级之前，要么将该目录的数据拷贝到新的你指定的data目录（比如/usr/local/mysql-5.7.9-linux-glibc2.5-x86_64/data ），要么修改my.cnf，将datadir指向/usr/local/mysql-5.6.27-linux-glibc2.5-x86_64/data，总之一定要确保my.cnf中的数据位置和你实际的数据位置是一致的，不管是默认的也好，还是你datadir指定的也好 4.关于降级问题的说明通过覆盖mysql系统表的方式存在问题，会导致启动不起来。官方建议如下： 官方MySQL5.7降级建议上述建议中使用的SQL语句可在mysql5.7的源码的srcipts/mysql_system_tables_fix_for_downgrade.sql中找到，或者直接运行这个sql脚本。 姜老师测试后发现，有bug; 可以启动，但是原来的用户表，无法访问。当前记录时间是2015-11-17，等待下一步解决方案。 二. MySQL的连接登录###1. 几种登录方式 方式一 mysql -p 该方法默认使用root用户, 可使用select user();查看当前用户 方式二 mysql -S /tmp/mysql.sock -u root -p 密码A 该方法适用于在安装MySQL主机上进行本地登录 方式三 mysql -h 127.0.0.1 -u root -p 密码B 使用&#39;root&#39;@&#39;127.0.0.1&#39;这个用户登录 方式四 mysql -h localhost -u root -p 密码A 该方式等价与【方式二】，且和【方式三】属于两个不同的“用户” ###2. 免密码登录 方式一 my.cnf增加[client]标签 123[client] user="root" password="你的密码" 12345678#单对定义不同的客户端[mysql] # 这个是给/usr/loca/mysql/bin/mysql 使用的user=rootpassword="你的密码"[mysqladmin] # 这个是给/usr/local/mysql/bin/mysqladmin使用的user=rootpassword="你的密码" **每个不同的客户端需要定义不同的标签，使用`[client]`可以统一** 方式二 login-path 1234567891011shell&gt; mysql_config_editor set -G vm1 -S /tmp/mysql.sock -u root -pEnter password [输入root的密码]shell&gt; mysql_config_editor print --all[vm1]user=rootpassword=*****socket=/tmp/mysql.sock#loginshell&gt; mysql --login-path=vm1 # 这样登录就不需要密码，且文件二进制存储 ,位置是 ~/.mylogin.cnf 该方式相对安全。如果server被黑了，该二进制文件还是会被破解 方式三 ~/.my.cnf, 自己当前家目录 1234#Filename: ~/.my.cnf[client]user="root"password="你的密码" 三. MySQL 参数介绍和设置###1. 参数的分类 全局参数：GLOBAL 可修改参数 不可修改参数 会话参数：SESSION 可修改参数 不可修改参数 1: 用户可在线修改非只读参数，只读参数只能预先在配置文件中进行设置，通过重启数据库实例,方可生效。 2: 所有的在线修改过的参数(GLOBAL/SESSION)，在重启后，都会丢失，不会写如my.cnf，无法将修改进行持久化 3: 有些参数，即存在于GLOBAL又存在于SESSION, 比如autocommit (PS：MySQL默认是提交的) ###2. 查看参数 12mysql&gt; show variables; # 显示当前mysql的所有参数，且无隐藏参数mysql&gt; show variables like "max_%"; #查以max_开头的变量 ###3. 设置参数 设置全局(GLOBAL)参数 12345mysql&gt; set global slow_query_log = off; #不加global，会提示错误 #slow_query_log是全局参数mysql&gt; set slow_query_log = off; # 下面就报错了，默认是会话参数ERROR 1229 (HY000): Variable 'slow_query_log' is a GLOBAL variable and should be set with SET GLOBAL 设置会话(SESSION)参数 123mysql&gt; set autocommit = 0; # 当前会话生效# 或者mysql&gt; set session autocommit = 0; # 当前会话生效 autocommit同样在GLOBAL中, 也有同样的参数 1mysql&gt; set global autocommit = 1; #当前实例，全局生效 注意：如果这个时候/etc/init.d/mysqld restart, 则全局的autocommit的值会变成默认值，或者依赖于my.cnf的设置值。 执行的效果如下： 12345678910111213141516171819202122232425mysql&gt; show variables like "slow%"; # 原值为ON+---------------------+----------+| Variable_name | Value |+---------------------+----------+| slow_launch_time | 2 || slow_query_log | OFF || slow_query_log_file | slow.log |+---------------------+----------+3 rows in set (0.00 sec)mysql&gt; select @@session.autocommit; # 等价于 slect @@autocomit;+----------------------+| @@session.autocommit |+----------------------+| 0 |+----------------------+1 row in set (0.00 sec)mysql&gt; select @@global.autocommit; +---------------------+| @@global.autocommit |+---------------------+| 1 |+---------------------+1 row in set (0.00 sec) 四. 权限管理###1. “用户 + IP”的概念MySQL中同一个用户名，比如Bob,能否登录，以及用什么密码登录，可以访问什么库等等，都需要加上IP，才可以表示一个完整的用户标识 `bob@127.0.0.1和bob@loalhost以及bob@192.168.1.100这三个其实是不同`的 用户标识 ###2. 用户权限管理 系统表权限信息: a) 用户名和IP是否允许 b) 查看mysql.user表 // 查看全局所有库的权限 c) 查看mysql.db表 // 查看指定库的权限 d) 查看mysql.table_priv表 // 查看指定表的权限 e) 查看mysql.column_priv表 // 查看指定列的权限 *tips: mysql&gt; desc [tablename]; 可以查看表的结构信息；* 常用权限： SQL语句：SELECT、INSERT、UPDATE、DELETE、INDEX 存储过程：CREATE ROUTINE、ALTER ROUTINE、EXECUTE、TRIGGER 管理权限：SUPER、RELOAD、SHOW DATABASE、SHUTDOWN、 所有权限猛戳这里 可选资源: MAX_QUERIES_PER_HOUR count MAX_UPDATES_PER_HOUR count MAX_CONNECTIONS_PER_HOUR count MAX_USER_CONNECTIONS count *tips:只能精确到小时，对于部分场景不适用，可以考虑中间件方式* 显示当前用户的权限 1234#这三个是同一个意思mysql&gt; show grants;mysql&gt; show grants for current_user;mysql&gt; show grants for current_user(); ###3. 基本操作123456789101112131415mysql&gt; create user 'bob'@'127.0.0.1' identified by '123'; #创建一个认证用户为'bob'@'127.0.0.1',密码是123mysql&gt; grant all on NWDB.* to 'bob'@'127.0.0.1'; #授予他NWDB库下面所有表的所有访问权限; *.*表示所有库的所有表mysql&gt; grant all on NWDB.* to 'alice'@'127.0.0.1' identified by '123'; #这个grant语句会搜索用户，如果用户不存在，则自动创建用户， #如果不带identified by, 则该用户名密码为空mysql&gt; grant all on *.* to 'tom'@'192.168.10.%' identified by '123' with grant option; #表示这个用户'tom'@'127.0.0.1'可以访问所有库的所有表， #同时，他还可以给其他用户授予权限(with grant option)， #注意如果，*.*改成了某一个指定的非USER库， #则tom没法去新建其他用户了，因为User库没有权限了 #192.168.10.% 表示属于192.168.10.0/24网段的用户可以访问 4. 撤销权限 revoke 关键字，该关键字只删除用户权限，不删除用户 revoke 语法同grant一致, 从grant ... to 变为revoke ... from]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL学习笔记（Day001-002：介绍和安装）]]></title>
    <url>%2F2018%2F05%2F30%2FMySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Day001-002%EF%BC%9A%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%AE%89%E8%A3%85%EF%BC%89%2F</url>
    <content type="text"><![CDATA[MySQL学习笔记（Day001-002：介绍和安装）@(MySQL学习) [TOC] ##一.MySQL版本选择 MySQL5.6以后的版本，推荐使用官方版本。 Percona：在5.6版本以后，MySQL将Percon之前优化集成到官方版本中; MariaDB：无INNODB;且核心代码较老 MySQL在5.6以后不断重构源码，安装包越来越大，功能和性能在持续改进 二. MySQL官方网站介绍官方网站：http://www.mysql.com Developer Zone： MySQL开发工程师板块 Articles： Oracle工程师自己的博客 Plant MySQL： 和MySQL相关从业人员的博客 Bugs：MySQL BugList Worklog：开发记录 Labs：MySQL实验性项目 Downloads：MySQL下载 Enterprise：MySQL企业版本相关，略过 Community：社区版，我们下载和使用社区版 MySQL Community Server：MySQL Server MySQL Fabric : 和管理相关的工具 MySQL Router：路由中间件 MySQL Utilities：MySQL应用程序包 MySQL Workbench：官方图型化管理界面 MySQL Proxy：MySQL代理。Alpha版本，不推荐 Documentation：MySQL文档 官方文档 版面更改，下载离线文档在左侧Menu的下面 PDF A4 EPUB HTML 三. MySQL下载 推荐下载Linux-Generic版本 Source Code版本主要作用是为了让开发人员研究源码使用，自己编译对性能提升不明显 不推荐Version 5.5.X，有部分bug 推荐使用Version 5.6.X和Version 5.7.X 下载地址：MySQL Community Server 5.7.9 Linux Generic x86-64bitMySQL Community Server 5.6.27 Linux Generic x86-64bit 四. MySQL安装 安装通用步骤： 解压缩mysql-VERSION-linux-glibc2.5-x86_64.tar.gz 打开INSTALL_BINARY 文件，按照shell&gt;开头的步骤进行操作 将export PATH=/安装路径/mysql/bin:$PATH添加到/etc/profile chkconfig mysqld on或者chkconfig mysqld.server on视你的环境而定，详细步骤如下 MySQL 5.6.X 安装： 123456789101112131415shell&gt; yum install libaio # Debain系用户:apt-get install libaio1shell&gt; groupadd mysqlshell&gt; useradd -r -g mysql mysqlshell&gt; cd /usr/localshell&gt; tar zxvf /path/to/mysql-VERSION-OS.tar.gzshell&gt; ln -s full-path-to-mysql-VERSION-OS mysqlshell&gt; cd mysqlshell&gt; chown -R mysql .shell&gt; chgrp -R mysql .shell&gt; scripts/mysql_install_db --user=mysqlshell&gt; chown -R root .shell&gt; chown -R mysql datashell&gt; bin/mysqld_safe --user=mysql &amp;# Next command is optionalshell&gt; cp support-files/mysql.server /etc/init.d/mysql.server MySQL 5.7.X 安装 12345678910111213141516171819shell&gt; groupadd mysqlshell&gt; useradd -r -g mysql mysqlshell&gt; cd /usr/localshell&gt; tar zxvf /path/to/mysql-VERSION-OS.tar.gzshell&gt; ln -s full-path-to-mysql-VERSION-OS mysqlshell&gt; cd mysqlshell&gt; mkdir mysql-filesshell&gt; chmod 770 mysql-filesshell&gt; chown -R mysql .shell&gt; chgrp -R mysql .shell&gt; bin/mysqld --initialize --user=mysql #该步骤中会产生零时 #root@localhost密码 #需要自己记录下来shell&gt; bin/mysql_ssl_rsa_setup shell&gt; chown -R root .shell&gt; chown -R mysql data mysql-filesshell&gt; bin/mysqld_safe --user=mysql &amp;# Next command is optionalshell&gt; cp support-files/mysql.server /etc/init.d/mysql.server 验证安装 data目录在安装之前是空目录，安装完成后应该有ibXXX等文件 安装过程中输出的信息中，不应该含有ERROR信息，错误信息默认会写入到$HOSTNAME.err的文件中 通过bin/mysql命令（5.7.X含有零时密码）可以正常登录 MySQL启动 mysqld_safe --user=mysql &amp; 即可启动，mysqld_safe是一个守护mysqld进程的脚本程序，旨在mysqld意外停止时，可以重启mysqld进程 也可以通过INSTALL_BINARRY中的的步骤，使用/etc/init.d/mysql.server start进行启动（启动脚本以你复制的实际名字为准，通常改名为mysqld,即/etc/init.d/mysqld start） 五. 附录 姜老师的配置文件my.cnf 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495[client]user=davidpassword=88888888[mysqld]########basic settings########server-id = 11 port = 3306user = mysqlbind_address = 10.166.224.32 #根据实际情况修改autocommit = 0 #5.6.X安装时，需要注释掉，安装完成后再打开character_set_server=utf8mb4skip_name_resolve = 1max_connections = 800max_connect_errors = 1000datadir = /data/mysql_data #根据实际情况修改,建议和程序分离存放transaction_isolation = READ-COMMITTEDexplicit_defaults_for_timestamp = 1join_buffer_size = 134217728tmp_table_size = 67108864tmpdir = /tmpmax_allowed_packet = 16777216sql_mode = "STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER"interactive_timeout = 1800wait_timeout = 1800read_buffer_size = 16777216read_rnd_buffer_size = 33554432sort_buffer_size = 33554432########log settings########log_error = error.logslow_query_log = 1slow_query_log_file = slow.loglog_queries_not_using_indexes = 1log_slow_admin_statements = 1log_slow_slave_statements = 1log_throttle_queries_not_using_indexes = 10expire_logs_days = 90long_query_time = 2min_examined_row_limit = 100########replication settings########master_info_repository = TABLErelay_log_info_repository = TABLElog_bin = bin.logsync_binlog = 1gtid_mode = onenforce_gtid_consistency = 1log_slave_updatesbinlog_format = row relay_log = relay.logrelay_log_recovery = 1binlog_gtid_simple_recovery = 1slave_skip_errors = ddl_exist_errors########innodb settings########innodb_page_size = 8192innodb_buffer_pool_size = 6G #根据实际情况修改innodb_buffer_pool_instances = 8innodb_buffer_pool_load_at_startup = 1innodb_buffer_pool_dump_at_shutdown = 1innodb_lru_scan_depth = 2000innodb_lock_wait_timeout = 5innodb_io_capacity = 4000innodb_io_capacity_max = 8000innodb_flush_method = O_DIRECTinnodb_file_format = Barracudainnodb_file_format_max = Barracudainnodb_log_group_home_dir = /redolog/ #根据实际情况修改innodb_undo_directory = /undolog/ #根据实际情况修改innodb_undo_logs = 128innodb_undo_tablespaces = 3innodb_flush_neighbors = 1innodb_log_file_size = 4G #根据实际情况修改innodb_log_buffer_size = 16777216innodb_purge_threads = 4innodb_large_prefix = 1innodb_thread_concurrency = 64innodb_print_all_deadlocks = 1innodb_strict_mode = 1innodb_sort_buffer_size = 67108864 ########semi sync replication settings########plugin_dir=/usr/local/mysql/lib/plugin #根据实际情况修改plugin_load = "rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so"loose_rpl_semi_sync_master_enabled = 1loose_rpl_semi_sync_slave_enabled = 1loose_rpl_semi_sync_master_timeout = 5000[mysqld-5.7]innodb_buffer_pool_dump_pct = 40innodb_page_cleaners = 4innodb_undo_log_truncate = 1innodb_max_undo_log_size = 2Ginnodb_purge_rseg_truncate_frequency = 128binlog_gtid_simple_recovery=1log_timestamps=systemtransaction_write_set_extraction=MURMUR32show_compatibility_56=on 几个重要的参数配置和说明 innodb_log_file_size = 4G :做实验可以更改的小点，线上环境推荐用4G，以前5.5和5.1等版本之所以官方给的值很小，是因为太大后有bug，现在bug已经修复 innodb_undo_logs = 128和innodb_undo_tablespaces = 3建议在安装之前就确定好该值，后续修改比较麻烦 [mysqld]，[mysqld-5.7]这种tag表明了下面的配置在什么版本下才生效,[mysqld]下均生效 autocommit,这个参数在5.5.X以后才有，安装5.6.X的时候要注意先把该参数注释掉，等安装完成后，再行打开, 5.7.X无需预先注释 datadir, innodb_log_group_home_dir, innodb_undo_directory一定要注意他的权限是 mysql:mysql my.cnf问题 使用mysqld --help -vv | grep my.cnf查看mysql的配置文件读取顺序 后读取的my.cnf中的配置，如果有相同项，会覆盖之前的配置 使用--defaults-files可指定配置文件]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 博客搭建指南]]></title>
    <url>%2F2018%2F05%2F30%2Fhexolog%2F</url>
    <content type="text"><![CDATA[Hexo 博客搭建指南Hexo的简洁、神秘让我跃跃欲试，在使用过程中遇到了很多问题，整理此文，一是方便其他技术人搭建自己的博客，二是给自己的学习之旅做个总结。本文未完结，欢迎star、fork，如果有错误，请不吝指出。我搭建的博客地址：chenwenning.github.io 1 Hexo介绍Hexo是基于NodeJs的静态博客框架，简单、轻量，其生成的静态网页可以托管在Github和Heroku上。 超快速度 支持MarkDown 一键部署 丰富的插件 下面以我的博客为例，chenwenning.github.io 2 环境准备2.1 安装node.js去nodejs官网下载对应系统的安装包，按提示安装。 检验安装成功：1$ node -v 2.2 安装hexo1$ npm install hexo-cli -g 注意：Mac系统，则需要1$ sudo npm install hexo-cli -g 3 利用Hexo搭建一个博客3.1 创建博客目录chenwenning.github.io123$ hexo init chenwenning.github.io$ cd chenwenning.github.io$ npm install 3.2 生成静态页面12$ hexo clean$ hexo g g 即generate 3.3 运行1$ hexo s s 即server 然后打开浏览器，输入地址 localhost:4000 即可看到效果 4 发一篇文章试试4.1 命令方式1$ hexo new test 此时会在source/_posts目录下生成test.md文件，输入些许内容，然后保存. 生成下，看看效果 123$ hexo clean$ hexo g$ hexo s 访问 localhost:4000 即可 4.2 直接方式在 source/_posts/下新建一个.md文件也可 5 配置网站的设置大部分都在_config.yml文件中，详细配置可以查看官方文档 下面只列出简单常用配置 title -&gt; 网站标题 subtitle -&gt; 网站副标题 description -&gt; 网站描述 author -&gt; 您的名字 language -&gt; 网站使用的语言 坑：进行配置时，需要在冒号:后加一个英文空格 1title: Droidlover 6 换一个好看的主题Hexo 中有很多主题，可以在官网查看。这里我推荐hexo-theme-next，下面列举更换主题的一般套路： 6.1 下载主题资源1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 6.2 应用下载的主题在网站配置文件_config.yml中，配置theme 1theme: next next是主题名称，具体的可查看主题的文档 6.3 主题其他配置可在/theme/{theme}/_config.yml 主题的配置文件下进行主题的配置。 接下来，可以执行万能的调试命令看看效果 123$ hexo clean$ hexo g$ hexo s 7 部署到Github7.1 有个github账号xxx7.2 创建一个xxx.github.io的public仓库如果您的账户名是chenwenning,则需要创建一个chenwenning.github.io的public仓库. 7.3 安装 hexo-deployer-git1$ npm install hexo-deployer-git --save 7.4 网站配置git在网站的_config.yml中配置deploy 1234deploy: type: git repo: &lt;repository url&gt; branch: [branch] branch为分支，默认为master,可以不配置repo为仓库地址，在github上新建仓库后，可复制此地址 7.5 部署1$ hexo d d 即deploy 8 贴标签，方便搜索8.1 两个确认 确认站点配置文件有 1tag_dir: tags 确认主题配置文件有 1tags: tags 8.2 新建tags页面1$ hexo new page tags 此时会在source/下生成tags/index.md文件 8.3 修改source/tags/index.md1234title: tagsdate: 2015-10-20 06:49:50type: &quot;tags&quot;comments: false date 可保持系统生成的时间，12type: &quot;tags&quot;comments: false 很重要 8.4 在文章中添加tags在文章xx.md中添加： 1234tags: - Tag1 - Tag2 - Tag3 多个Tag可按上面的格式添加。 其文件头部类似： 123456title: TagEditTextdate: 2016-11-19 10:44:25tags: - Tag1 - Tag2 - Tag3 9 分类，给文章归档9.1 两个确认 确认站点配置文件打开了 1category_dir: categories 确认主题配置文件打开了 1categories: /categories 9.2 新建categories文件1$ hexo new page categories 此时会在source目录下生成categories/index.md文件 9.3 修改categories/index.md1234title: categoriesdate: 2015-10-20 06:49:50type: &quot;categories&quot;comments: false date 可保持系统生成的时间，12type: &quot;categories&quot;comments: false 很重要 9.4 在文章中添加categories在文章xx.md中添加： 12categories: - cate 其文件头部类似： 1234title: TagEditTextdate: 2016-11-19 10:44:25categories: - cate 10 添加评论功能评论功能在国内一般使用多说。 10.1 注册多说账号10.2 创建站点需要注意的是，填写的多说域名不能更改，会在后面使用，在这里我配置成droidlover 10.3 配置在hexo主题配置文件中搜索：1duoshuo_shortname ，然后打开开关，配置成前面设置的多说域名，如下：1duoshuo_shortname: droidlover 有时，可能需要一段js 12345678910111213141516&lt;!-- 多说评论框 start --&gt; &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;请将此处替换成文章在你的站点中的ID&quot; data-title=&quot;请替换成文章的标题&quot; data-url=&quot;请替换成文章的网址&quot;&gt;&lt;/div&gt;&lt;!-- 多说评论框 end --&gt;&lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;&lt;script type=&quot;text/javascript&quot;&gt;var duoshuoQuery = &#123;short_name:&quot;droidlover&quot;&#125;; (function() &#123; var ds = document.createElement(&apos;script&apos;); ds.type = &apos;text/javascript&apos;;ds.async = true; ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//static.duoshuo.com/embed.js&apos;; ds.charset = &apos;UTF-8&apos;; (document.getElementsByTagName(&apos;head&apos;)[0] || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds); &#125;)(); &lt;/script&gt;&lt;!-- 多说公共JS代码 end --&gt; 现在，你可以运行看下效果了:) 11 hexo 更换电脑解决方案 （利用git分支来管理自己hexo的源文件）克隆gitHub上面生成的静态文件到本地： 1git clone https://github.com/yourname/hexo-test.github.io.git 把克隆到本地的文件除了git的文件都删掉，找不到git的文件的话就到删了吧。不要用hexo init初始化 将之前使用hexo写博客时候的整个目录（所有文件）搬过来。把该忽略的文件忽略了 创建一个叫hexo的分支 1git checkout -b hexo 提交复制过来的文件到暂存区 1git add --all 提交 1git commit -m &quot;新建分支源文件&quot; 推送分支到github 1git push --set-upstream origin hexo 克隆分支的操作 1git clone -b hexo https://github.com/yourname/hexo-test.github.io.git]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[首页文章]]></title>
    <url>%2F2018%2F05%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to chenwening! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hello</category>
      </categories>
      <tags>
        <tag>hello words</tag>
      </tags>
  </entry>
</search>
